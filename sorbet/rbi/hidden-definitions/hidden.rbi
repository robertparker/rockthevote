# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def bsearch(); end

  def bsearch_index(); end

  def collect!(); end

  def dig(*_); end

  def flatten!(*_); end

  def pack(*_); end

  def replace(_); end

  def shelljoin(); end

  def to_csv(**options); end

  def to_h(); end
end

class Array
  def self.try_convert(_); end
end

class BasicObject
  def as_null_object(); end

  def null_object?(); end

  def received_message?(message, *args, &block); end

  def should(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not_receive(message, &block); end

  def should_receive(message, opts=T.unsafe(nil), &block); end

  def stub(message_or_hash, opts=T.unsafe(nil), &block); end

  def stub_chain(*chain, &blk); end

  def unstub(message); end
end

BasicObject::BasicObject = BasicObject

class BigDecimal
  def clone(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  SIGN_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.new(*args, **kwargs); end
end

class Binding
  def clone(); end

  def irb(); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def git(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end
end

class Bundler::GemHelper
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_command(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Vertex
  def _recursive_predecessors(vertices=T.unsafe(nil)); end

  def _recursive_successors(vertices=T.unsafe(nil)); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_plugins(); end

  def plugin_commands(plugin); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.list(); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubygemsIntegration
  def add_to_load_path(paths); end

  def all_specs(); end

  def backport_ext_builder_monitor(); end

  def correct_for_windows_path(path); end

  def default_stubs(); end

  def find_name(name); end

  def gem_remote_fetcher(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def use_gemdeps(gemfile); end
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Source::Git
  def glob(); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base::ClassMethods
  def all_commands(); end

  def all_tasks(); end

  def allow_incompatible_default_type!(); end

  def argument(name, options=T.unsafe(nil)); end

  def arguments(); end

  def attr_accessor(*_); end

  def attr_reader(*_); end

  def attr_writer(*_); end

  def baseclass(); end

  def basename(); end

  def build_option(name, options, scope); end

  def build_options(options, scope); end

  def check_default_type(); end

  def check_default_type!(); end

  def check_unknown_options(); end

  def check_unknown_options!(); end

  def check_unknown_options?(config); end

  def class_option(name, options=T.unsafe(nil)); end

  def class_options(options=T.unsafe(nil)); end

  def class_options_help(shell, groups=T.unsafe(nil)); end

  def commands(); end

  def create_command(meth); end

  def create_task(meth); end

  def disable_required_check?(command_name); end

  def dispatch(command, given_args, given_opts, config); end

  def exit_on_failure?(); end

  def find_and_refresh_command(name); end

  def find_and_refresh_task(name); end

  def from_superclass(method, default=T.unsafe(nil)); end

  def group(name=T.unsafe(nil)); end

  def handle_argument_error(command, error, args, arity); end

  def handle_no_command_error(command, has_namespace=T.unsafe(nil)); end

  def handle_no_task_error(command, has_namespace=T.unsafe(nil)); end

  def inherited(klass); end

  def initialize_added(); end

  def is_thor_reserved_word?(word, type); end

  def method_added(meth); end

  def namespace(name=T.unsafe(nil)); end

  def no_commands(&block); end

  def no_commands?(); end

  def no_commands_context(); end

  def no_tasks(&block); end

  def print_options(shell, options, group_name=T.unsafe(nil)); end

  def public_command(*names); end

  def public_task(*names); end

  def remove_argument(*names); end

  def remove_class_option(*names); end

  def remove_command(*names); end

  def remove_task(*names); end

  def start(given_args=T.unsafe(nil), config=T.unsafe(nil)); end

  def stop_on_unknown_option?(command_name); end

  def strict_args_position(); end

  def strict_args_position!(); end

  def strict_args_position?(config); end

  def tasks(); end
end

module Bundler::Thor::Base::ClassMethods
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def reverse_merge!(other_hash); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

Bundler::Thor::Correctable = DidYouMean::Correctable

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*_); end

  def self.printable_tasks(*_); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end

module Bundler::Thor::Invocation::ClassMethods
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::NoKwargSpellChecker
  def initialize(dictionary); end
end

class Bundler::Thor::NoKwargSpellChecker
end

class Bundler::Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

module Bundler::Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Bundler::Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end

  def as_unicode(); end

  def ask(statement, *args); end

  def ask_filtered(statement, color, options); end

  def ask_simply(statement, color, options); end

  def base(); end

  def base=(base); end

  def can_display_colors?(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def error(statement); end

  def file_collision(destination); end

  def file_collision_help(); end

  def git_merge_tool(); end

  def indent(count=T.unsafe(nil)); end

  def is?(value); end

  def lookup_color(color); end

  def merge(destination, content); end

  def merge_tool(); end

  def mute(); end

  def mute?(); end

  def no?(statement, color=T.unsafe(nil)); end

  def padding(); end

  def padding=(value); end

  def prepare_message(message, *color); end

  def print_in_columns(array); end

  def print_table(array, options=T.unsafe(nil)); end

  def print_wrapped(message, options=T.unsafe(nil)); end

  def quiet?(); end

  def say(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_status(status, message, log_status=T.unsafe(nil)); end

  def set_color(string, *_); end

  def show_diff(destination, content); end

  def stderr(); end

  def stdout(); end

  def terminal_width(); end

  def truncate(string, width); end

  def unix?(); end

  def yes?(statement, color=T.unsafe(nil)); end
  DEFAULT_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
end

class Bundler::Thor::Shell::Color
  def are_colors_disabled?(); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Color
end

class Bundler::Thor::Shell::HTML
  def ask(statement, color=T.unsafe(nil)); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::HTML
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::BadURIError
end

class Bundler::URI::BadURIError
end

class Bundler::URI::Error
end

class Bundler::URI::Error
end

module Bundler::URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

module Bundler::URI::Escape
end

class Bundler::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Bundler::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::File
end

class Bundler::URI::Generic
  include ::Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Bundler::URI::HTTP
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTP
end

class Bundler::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTPS
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAP
end

class Bundler::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAPS
end

class Bundler::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::MailTo
end

Bundler::URI::Parser = Bundler::URI::RFC2396_Parser

Bundler::URI::REGEXP = Bundler::URI::RFC2396_REGEXP

class Bundler::URI::RFC2396_Parser
  include ::Bundler::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Bundler::URI::RFC2396_Parser
end

module Bundler::URI::RFC2396_REGEXP
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
end

module Bundler::URI::RFC2396_REGEXP
end

class Bundler::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::RFC3986_Parser
end

module Bundler::URI::Util
end

module Bundler::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module Bundler::URI
  extend ::Bundler::URI::Escape
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.scheme_list(); end

  def self.split(uri); end
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler
  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end

  def self.with_unbundled_env(); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class CSV
  def add_row(row); end

  def binmode(*args, &block); end

  def binmode?(); end

  def close(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def col_sep(); end

  def convert(name=T.unsafe(nil), &converter); end

  def converters(); end

  def each(&block); end

  def encoding(); end

  def eof(); end

  def eof?(); end

  def external_encoding(*args, &block); end

  def fcntl(*args, &block); end

  def field_size_limit(); end

  def fileno(*args, &block); end

  def flock(*args); end

  def flush(*args, &block); end

  def force_quotes?(); end

  def fsync(*args, &block); end

  def gets(); end

  def header_convert(name=T.unsafe(nil), &converter); end

  def header_converters(); end

  def header_row?(); end

  def headers(); end

  def internal_encoding(*args, &block); end

  def ioctl(*args); end

  def isatty(*args, &block); end

  def liberal_parsing?(); end

  def line(); end

  def lineno(); end

  def path(); end

  def pid(*args, &block); end

  def pos(*args, &block); end

  def pos=(*args, &block); end

  def puts(row); end

  def quote_char(); end

  def readlines(); end

  def reopen(*args, &block); end

  def return_headers?(); end

  def rewind(); end

  def row_sep(); end

  def seek(*args, &block); end

  def shift(); end

  def skip_blanks?(); end

  def skip_lines(); end

  def stat(*args); end

  def string(*args, &block); end

  def sync(*args, &block); end

  def sync=(*args, &block); end

  def tell(*args, &block); end

  def to_i(); end

  def to_io(); end

  def truncate(*args, &block); end

  def tty?(*args, &block); end

  def unconverted_fields?(); end

  def write_headers?(); end
  ConverterEncoding = ::T.let(nil, ::T.untyped)
  Converters = ::T.let(nil, ::T.untyped)
  DateMatcher = ::T.let(nil, ::T.untyped)
  DateTimeMatcher = ::T.let(nil, ::T.untyped)
  HeaderConverters = ::T.let(nil, ::T.untyped)
end

class CSV::FieldInfo
  def header(); end

  def header=(_); end

  def index(); end

  def index=(_); end

  def line(); end

  def line=(_); end
end

class CSV::FieldInfo
  def self.[](*_); end

  def self.members(); end
end

class CSV::FieldsConverter
  include ::Enumerable
  def add_converter(name=T.unsafe(nil), &converter); end

  def convert(fields, headers, lineno); end

  def each(&block); end

  def empty?(); end

  def initialize(options=T.unsafe(nil)); end
end

class CSV::FieldsConverter
end

class CSV::MalformedCSVError
  def initialize(message, line_number); end

  def line_number(); end

  def lineno(); end
end

class CSV::Parser
  def column_separator(); end

  def field_size_limit(); end

  def header_row?(); end

  def headers(); end

  def initialize(input, options); end

  def liberal_parsing?(); end

  def line(); end

  def lineno(); end

  def parse(&block); end

  def quote_character(); end

  def return_headers?(); end

  def row_separator(); end

  def skip_blanks?(); end

  def skip_lines(); end

  def unconverted_fields?(); end

  def use_headers?(); end
  SCANNER_TEST = ::T.let(nil, ::T.untyped)
end

class CSV::Parser::InputsScanner
  def each_line(row_separator); end

  def eos?(); end

  def initialize(inputs, encoding, chunk_size: T.unsafe(nil)); end

  def keep_back(); end

  def keep_drop(); end

  def keep_end(); end

  def keep_start(); end

  def rest(); end

  def scan(pattern); end

  def scan_all(pattern); end
end

class CSV::Parser::InputsScanner
end

class CSV::Parser::InvalidEncoding
end

class CSV::Parser::InvalidEncoding
end

class CSV::Parser::Scanner
  def each_line(row_separator); end

  def initialize(*args); end

  def keep_back(); end

  def keep_drop(); end

  def keep_end(); end

  def keep_start(); end

  def scan_all(_); end
end

class CSV::Parser::Scanner
end

class CSV::Parser
end

class CSV::Row
  def <<(arg); end

  def ==(other); end

  def [](header_or_index, minimum_index=T.unsafe(nil)); end

  def []=(*args); end

  def delete(header_or_index, minimum_index=T.unsafe(nil)); end

  def delete_if(&block); end

  def dig(index_or_header, *indexes); end

  def each(&block); end

  def each_pair(&block); end

  def empty?(*args, &block); end

  def fetch(header, *varargs); end

  def field(header_or_index, minimum_index=T.unsafe(nil)); end

  def field?(data); end

  def field_row?(); end

  def fields(*headers_and_or_indices); end

  def has_key?(header); end

  def header?(header); end

  def header_row?(); end

  def headers(); end

  def include?(header); end

  def index(header, minimum_index=T.unsafe(nil)); end

  def initialize(headers, fields, header_row=T.unsafe(nil)); end

  def key?(header); end

  def length(*args, &block); end

  def member?(header); end

  def push(*args); end

  def row(); end

  def size(*args, &block); end

  def to_ary(*_); end

  def to_csv(**options); end

  def to_h(); end

  def to_hash(); end

  def to_s(**options); end

  def values_at(*headers_and_or_indices); end
end

class CSV::Row
  extend ::Forwardable
end

class CSV::Table
  def <<(row_or_array); end

  def ==(other); end

  def [](index_or_header); end

  def []=(index_or_header, value); end

  def by_col(); end

  def by_col!(); end

  def by_col_or_row(); end

  def by_col_or_row!(); end

  def by_row(); end

  def by_row!(); end

  def delete(*indexes_or_headers); end

  def delete_if(&block); end

  def dig(index_or_header, *index_or_headers); end

  def each(&block); end

  def empty?(*args, &block); end

  def headers(); end

  def initialize(array_of_rows, headers: T.unsafe(nil)); end

  def length(*args, &block); end

  def mode(); end

  def push(*rows); end

  def size(*args, &block); end

  def table(); end

  def to_a(); end

  def to_csv(write_headers: T.unsafe(nil), **options); end

  def to_s(write_headers: T.unsafe(nil), **options); end

  def values_at(*indices_or_headers); end
end

class CSV::Table
  extend ::Forwardable
end

class CSV::Writer
  def <<(row); end

  def headers(); end

  def initialize(output, options); end

  def lineno(); end

  def rewind(); end
end

class CSV::Writer
end

class CSV
  extend ::Forwardable
  def self.filter(input=T.unsafe(nil), output=T.unsafe(nil), **options); end

  def self.generate_line(row, **options); end

  def self.instance(data=T.unsafe(nil), **options); end

  def self.open(filename, mode=T.unsafe(nil), **options); end

  def self.readlines(*args); end

  def self.table(path, **options); end
end

class Class
  def any_instance(); end

  def json_creatable?(); end
end

class Complex
  def self.polar(*_); end

  def self.rect(*_); end

  def self.rectangular(*_); end
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Delegator
  def !=(obj); end

  def ==(obj); end

  def __getobj__(); end

  def __setobj__(obj); end

  def eql?(obj); end

  def initialize(obj); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(m, *args, &block); end

  def methods(all=T.unsafe(nil)); end

  def protected_methods(all=T.unsafe(nil)); end

  def public_methods(all=T.unsafe(nil)); end
end

class Delegator
  def self.const_missing(n); end

  def self.delegating_block(mid); end

  def self.public_api(); end
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.formatter(); end

  def self.formatter=(formatter); end
end

class Dir
  def children(); end

  def each_child(); end
end

class Dir
  def self.children(*_); end

  def self.each_child(*_); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.tmpdir(); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end

  def result_with_hash(hash); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

Emitter = Psych::Stream::Emitter

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def convert(_); end

  def convpath(); end

  def destination_encoding(); end

  def finish(); end

  def initialize(*_); end

  def insert_output(_); end

  def last_error(); end

  def primitive_convert(*_); end

  def primitive_errinfo(); end

  def putback(*_); end

  def replacement(); end

  def replacement=(replacement); end

  def source_encoding(); end
end

class Encoding::Converter
  def self.asciicompat_encoding(_); end

  def self.search_convpath(*_); end
end

class Encoding::InvalidByteSequenceError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_bytes(); end

  def incomplete_input?(); end

  def readagain_bytes(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::UndefinedConversionError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_char(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding
  def self._load(_); end

  def self.locale_charmap(); end
end

module Enumerable
  def chain(*_); end

  def chunk(); end

  def chunk_while(); end

  def each_entry(*_); end

  def grep_v(_); end

  def slice_after(*_); end

  def slice_before(*_); end

  def slice_when(); end

  def sum(*_); end

  def to_set(klass=T.unsafe(nil), *args, &block); end

  def uniq(); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Lazy
  def chunk(*_); end

  def chunk_while(*_); end

  def force(*_); end

  def slice_when(*_); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Exception
  def full_message(*_); end
end

class Exception
  def self.exception(*_); end

  def self.to_tty?(); end
end

class ExitCalledError
end

class ExitCalledError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class Fiber
  def resume(*_); end
end

class Fiber
  def self.yield(*_); end
end

class File
  Separator = ::T.let(nil, ::T.untyped)
end

class File::Stat
  def size?(); end
end

class File
  def self.empty?(_); end

  def self.exists?(_); end

  def self.lutime(*_); end

  def self.mkfifo(*_); end
end

FileList = Rake::FileList

module FileUtils
  include ::FileUtils::StreamUtils_
  def ruby(*args, &block); end

  def safe_ln(*args); end

  def sh(*cmd, &block); end

  def split_all(path); end
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

module Forwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_instance_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_instance_delegators(accessor, *methods); end

  def delegate(hash); end

  def instance_delegate(hash); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(*_); end
end

module GC
  def self.latest_gc_info(*_); end

  def self.stress=(stress); end

  def self.verify_internal_consistency(); end

  def self.verify_transient_heap_internal_consistency(); end
end

class Gem::Package::TarHeader
  def self.oct_or_256based(str); end
end

class Gem::RemoteFetcher
  def s3_uri_signer(uri); end
end

class Gem::RemoteFetcher::FetchError
  def initialize(message, uri); end

  def uri(); end

  def uri=(uri); end
end

class Gem::RemoteFetcher::FetchError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::S3URISigner
  def initialize(uri); end

  def sign(expiration=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end
  BASE64_URI_TRANSLATE = ::T.let(nil, ::T.untyped)
  EC2_METADATA_CREDENTIALS = ::T.let(nil, ::T.untyped)
end

class Gem::S3URISigner::ConfigurationError
  def initialize(message); end
end

class Gem::S3URISigner::ConfigurationError
end

class Gem::S3URISigner::InstanceProfileError
  def initialize(message); end
end

class Gem::S3URISigner::InstanceProfileError
end

class Gem::S3URISigner::S3Config
  def access_key_id(); end

  def access_key_id=(_); end

  def region(); end

  def region=(_); end

  def secret_access_key(); end

  def secret_access_key=(_); end

  def security_token(); end

  def security_token=(_); end
end

class Gem::S3URISigner::S3Config
  def self.[](*_); end

  def self.members(); end
end

class Gem::S3URISigner
end

class Gem::Specification
  extend ::Enumerable
end

module Gem::Util
  def self.correct_for_windows_path(path); end
end

module HTTParty
  VERSION = ::T.let(nil, ::T.untyped)
end

class HTTParty::ConnectionAdapter
  OPTION_DEFAULTS = ::T.let(nil, ::T.untyped)
  StripIpv6BracketsRegex = ::T.let(nil, ::T.untyped)
end

class HTTParty::CookieHash
  CLIENT_COOKIES = ::T.let(nil, ::T.untyped)
end

class HTTParty::Logger::ApacheFormatter
  TAG_NAME = ::T.let(nil, ::T.untyped)
end

class HTTParty::Logger::CurlFormatter
  IN = ::T.let(nil, ::T.untyped)
  OUT = ::T.let(nil, ::T.untyped)
  TAG_NAME = ::T.let(nil, ::T.untyped)
end

class HTTParty::Logger::LogstashFormatter
  TAG_NAME = ::T.let(nil, ::T.untyped)
end

class HTTParty::Parser
  SupportedFormats = ::T.let(nil, ::T.untyped)
  UTF8_BOM = ::T.let(nil, ::T.untyped)
end

class HTTParty::Request
  JSON_API_QUERY_STRING_NORMALIZER = ::T.let(nil, ::T.untyped)
  NON_RAILS_QUERY_STRING_NORMALIZER = ::T.let(nil, ::T.untyped)
  SupportedHTTPMethods = ::T.let(nil, ::T.untyped)
  SupportedURISchemes = ::T.let(nil, ::T.untyped)
end

class HTTParty::Response
  CODES_TO_OBJ = ::T.let(nil, ::T.untyped)
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def <(_); end

  def <=(_); end

  def >(_); end

  def >=(_); end

  def compact(); end

  def compact!(); end

  def default_proc(); end

  def default_proc=(default_proc); end

  def fetch_values(*_); end

  def flatten(*_); end

  def index(_); end

  def replace(_); end

  def slice(*_); end

  def to_h(); end

  def to_proc(); end

  def transform_keys(); end

  def transform_keys!(); end

  def transform_values(); end

  def transform_values!(); end

  def update(*_); end
end

class Hash
  def self.try_convert(_); end
end

class IO
  def external_encoding(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def pathconf(_); end

  def pread(*_); end

  def pwrite(_, _1); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def write_nonblock(buf, exception: T.unsafe(nil)); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.foreach(*_); end
end

class IPAddr
  include ::Comparable
  def &(other); end

  def <<(num); end

  def ==(other); end

  def ===(other); end

  def >>(num); end

  def eql?(other); end

  def family(); end

  def hton(); end

  def include?(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def ip6_arpa(); end

  def ip6_int(); end

  def ipv4?(); end

  def ipv4_compat(); end

  def ipv4_compat?(); end

  def ipv4_mapped(); end

  def ipv4_mapped?(); end

  def ipv6?(); end

  def link_local?(); end

  def loopback?(); end

  def mask(prefixlen); end

  def mask!(mask); end

  def native(); end

  def prefix(); end

  def prefix=(prefix); end

  def private?(); end

  def reverse(); end

  def set(addr, *family); end

  def succ(); end

  def to_i(); end

  def to_range(); end

  def to_string(); end

  def |(other); end

  def ~(); end
  IN4MASK = ::T.let(nil, ::T.untyped)
  IN6FORMAT = ::T.let(nil, ::T.untyped)
  IN6MASK = ::T.let(nil, ::T.untyped)
  RE_IPV4ADDRLIKE = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_COMPRESSED = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_FULL = ::T.let(nil, ::T.untyped)
end

class IPAddr::AddressFamilyError
end

class IPAddr::AddressFamilyError
end

class IPAddr::Error
end

class IPAddr::Error
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidPrefixError
end

class IPAddr::InvalidPrefixError
end

class IPAddr
  def self.new_ntoh(addr); end

  def self.ntop(addr); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def allbits?(_); end

  def anybits?(_); end

  def digits(*_); end

  def nobits?(_); end

  def pow(*_); end

  def to_bn(); end
end

class Integer
  def self.sqrt(_); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

JSONTree = Psych::Visitors::JSONTree

module Kernel
  def gem(dep, *reqs); end

  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def respond_to?(*_); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end
end

class KeyError
  include ::DidYouMean::Correctable
  def key(); end

  def receiver(); end
end

class LoadError
  def path(); end
end

class LocalJumpError
  def exit_value(); end

  def reason(); end
end

class Logger
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module MIME
end

class MIME::Type
  include ::Comparable
  def add_extensions(*extensions); end

  def ascii?(); end

  def binary?(); end

  def complete?(); end

  def content_type(); end

  def default_encoding(); end

  def docs(); end

  def docs=(docs); end

  def encode_with(coder); end

  def encoding(); end

  def encoding=(enc); end

  def eql?(other); end

  def extensions(); end

  def extensions=(value); end

  def friendly(lang=T.unsafe(nil)); end

  def i18n_key(); end

  def init_with(coder); end

  def initialize(content_type); end

  def like?(other); end

  def media_type(); end

  def obsolete(); end

  def obsolete=(obsolete); end

  def obsolete?(); end

  def preferred_extension(); end

  def preferred_extension=(value); end

  def priority_compare(other); end

  def raw_media_type(); end

  def raw_sub_type(); end

  def registered(); end

  def registered=(registered); end

  def registered?(); end

  def signature(); end

  def signature=(signature); end

  def signature?(); end

  def simplified(); end

  def sub_type(); end

  def to_h(); end

  def to_json(*args); end

  def to_str(); end

  def use_instead(); end

  def use_instead=(use_instead); end

  def xref_urls(); end

  def xrefs(); end

  def xrefs=(xrefs); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class MIME::Type::Columnar
  def docs(*args); end

  def docs=(*args); end

  def encoding(*args); end

  def encoding=(*args); end

  def friendly(*args); end

  def initialize(container, content_type, extensions); end

  def obsolete(*args); end

  def obsolete=(*args); end

  def obsolete?(*args); end

  def preferred_extension(*args); end

  def preferred_extension=(*args); end

  def registered(*args); end

  def registered=(*args); end

  def registered?(*args); end

  def signature(*args); end

  def signature=(*args); end

  def signature?(*args); end

  def use_instead(*args); end

  def use_instead=(*args); end

  def xref_urls(*args); end

  def xrefs(*args); end

  def xrefs=(*args); end
end

class MIME::Type::Columnar
end

class MIME::Type::InvalidContentType
  def initialize(type_string); end
end

class MIME::Type::InvalidContentType
end

class MIME::Type::InvalidEncoding
  def initialize(encoding); end
end

class MIME::Type::InvalidEncoding
end

class MIME::Type
  def self.i18n_key(content_type); end

  def self.match(content_type); end

  def self.simplified(content_type, remove_x_prefix: T.unsafe(nil)); end
end

class MIME::Types
  include ::Enumerable
  def [](type_id, complete: T.unsafe(nil), registered: T.unsafe(nil)); end

  def add(*types); end

  def add_type(type, quiet=T.unsafe(nil)); end

  def count(); end

  def each(&blk); end

  def of(filename); end

  def type_for(filename); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class MIME::Types::Cache
  def data(); end

  def data=(_); end

  def version(); end

  def version=(_); end
end

class MIME::Types::Cache
  def self.[](*_); end

  def self.load(cache_file=T.unsafe(nil)); end

  def self.members(); end

  def self.save(types=T.unsafe(nil), cache_file=T.unsafe(nil)); end
end

module MIME::Types::Columnar
  def load_base_data(path); end
  LOAD_MUTEX = ::T.let(nil, ::T.untyped)
end

module MIME::Types::Columnar
  def self.extended(obj); end
end

class MIME::Types::Container
  def ==(*args, &block); end

  def [](key); end

  def []=(key, value); end

  def add(key, value); end

  def container(); end

  def container=(container); end

  def count(*args, &block); end

  def each(*args, &block); end

  def each_value(*args, &block); end

  def empty?(*args, &block); end

  def encode_with(coder); end

  def flat_map(*args, &block); end

  def init_with(coder); end

  def initialize(hash=T.unsafe(nil)); end

  def keys(*args, &block); end

  def marshal_dump(); end

  def marshal_load(hash); end

  def merge(other); end

  def merge!(other); end

  def normalize(); end

  def select(*args, &block); end

  def to_hash(); end

  def values(*args, &block); end
end

class MIME::Types::Container
  extend ::Forwardable
end

module MIME::Types::Data
  PATH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module MIME::Types::Data
end

class MIME::Types::Loader
  def container(); end

  def initialize(path=T.unsafe(nil), container=T.unsafe(nil)); end

  def load(options=T.unsafe(nil)); end

  def load_columnar(); end

  def load_json(); end

  def load_yaml(); end

  def path(); end
end

class MIME::Types::Loader
  def self.load(options=T.unsafe(nil)); end

  def self.load_from_json(filename); end

  def self.load_from_yaml(filename); end
end

class MIME::Types::WarnLogger
  def initialize(_one, _two=T.unsafe(nil), _three=T.unsafe(nil)); end
end

class MIME::Types::WarnLogger::WarnLogDevice
  def initialize(*_); end

  def write(m); end
end

class MIME::Types::WarnLogger::WarnLogDevice
end

class MIME::Types::WarnLogger
end

class MIME::Types
  extend ::Enumerable
  def self.[](type_id, complete: T.unsafe(nil), registered: T.unsafe(nil)); end

  def self.add(*types); end

  def self.count(); end

  def self.each(&blk); end

  def self.logger(); end

  def self.logger=(logger); end

  def self.of(filename); end

  def self.type_for(filename); end
end

module MIME
end

module Marshal
  def self.restore(*_); end
end

class Module
  def context(*a, &b); end

  def deprecate_constant(*_); end

  def describe(*a, &b); end

  def example_group(*a, &b); end

  def fcontext(*a, &b); end

  def fdescribe(*a, &b); end

  def rake_extension(method); end

  def shared_context(name, *args, &block); end

  def shared_examples(name, *args, &block); end

  def shared_examples_for(name, *args, &block); end

  def undef_method(*_); end

  def xcontext(*a, &b); end

  def xdescribe(*a, &b); end
end

class Module
  def self.used_modules(); end
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_mon_enter(); end
end

class MonitorMixin::ConditionVariable
  def broadcast(); end

  def initialize(monitor); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(); end

  def wait_while(); end
end

module MonitorMixin
  def self.extend_object(obj); end
end

module MultiXml
  CONTENT_ROOT = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  DISALLOWED_XML_TYPES = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  REQUIREMENT_MAP = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

class MultiXml::DisallowedTypeError
  def initialize(type); end
end

class MultiXml::DisallowedTypeError
end

class MultiXml::NoParserError
end

class MultiXml::NoParserError
end

class MultiXml::ParseError
end

class MultiXml::ParseError
end

module MultiXml
  def self.default_parser(); end

  def self.parse(xml, options=T.unsafe(nil)); end

  def self.parser(); end

  def self.parser=(new_parser); end
end

class NameError
  include ::DidYouMean::Correctable
  def name(); end

  def receiver(); end
end

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException

Net::HTTPClientErrorCode = Net::HTTPClientError

Net::HTTPClientException = Net::HTTPServerException

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

class Net::HTTPGatewayTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPGatewayTimeout
end

class Net::HTTPInformation
end

Net::HTTPInformationCode::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPInformation
end

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

Net::HTTPRedirectionCode = Net::HTTPRedirection

class Net::HTTPRequestTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRequestTimeout
end

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPServerErrorCode = Net::HTTPServerError

class Net::HTTP
end

Net::HTTPSession::ProxyDelta = Net::HTTP::ProxyDelta

Net::HTTPSession::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTP
end

class Net::HTTPSuccess
end

Net::HTTPSuccessCode::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPSuccess
end

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_i(); end
end

class NoMethodError
  def args(); end

  def private_call?(); end
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class ObjectSpace::WeakMap
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def key?(_); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

module ObjectSpace
  def self.count_objects(*_); end

  def self.define_finalizer(*_); end

  def self.garbage_collect(*_); end

  def self.undefine_finalizer(_); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

class OpenSSL::PKey::RSA
  def sign_pss(*_); end

  def verify_pss(*_); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  def add_certificate(*_); end

  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end

  def enable_fallback_scsv(); end

  def max_version=(version); end

  def min_version=(version); end
  DEFAULT_TMP_DH_CALLBACK = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def tmp_key(); end
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

class Pathname
  def empty?(); end

  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  def <<(_); end

  def ===(*_); end

  def >>(_); end

  def clone(); end

  def yield(*_); end
end

module Process
  CLOCK_MONOTONIC_RAW_APPROX = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW_APPROX = ::T.let(nil, ::T.untyped)
end

module Process::Sys
  def self.getegid(); end
end

class Process::Tms
  def cstime(); end

  def cstime=(_); end

  def cutime(); end

  def cutime=(_); end

  def stime(); end

  def stime=(_); end

  def utime(); end

  def utime=(_); end
end

class Process::Tms
  def self.[](*_); end

  def self.members(); end
end

module Process
  def self.last_status(); end

  def self.setpgrp(); end
end

module Psych
  LIBYAML_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::BadAlias
end

class Psych::BadAlias
end

class Psych::ClassLoader
  def big_decimal(); end

  def complex(); end

  def date(); end

  def date_time(); end

  def exception(); end

  def load(klassname); end

  def object(); end

  def psych_omap(); end

  def psych_set(); end

  def range(); end

  def rational(); end

  def regexp(); end

  def struct(); end

  def symbol(); end

  def symbolize(sym); end
  BIG_DECIMAL = ::T.let(nil, ::T.untyped)
  CACHE = ::T.let(nil, ::T.untyped)
  COMPLEX = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  DATE_TIME = ::T.let(nil, ::T.untyped)
  EXCEPTION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  PSYCH_OMAP = ::T.let(nil, ::T.untyped)
  PSYCH_SET = ::T.let(nil, ::T.untyped)
  RANGE = ::T.let(nil, ::T.untyped)
  RATIONAL = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
end

class Psych::ClassLoader::Restricted
  def initialize(classes, symbols); end
end

class Psych::ClassLoader::Restricted
end

class Psych::ClassLoader
end

class Psych::Coder
  def [](k); end

  def []=(k, v); end

  def add(k, v); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(tag); end

  def map(tag=T.unsafe(nil), style=T.unsafe(nil)); end

  def map=(map); end

  def object(); end

  def object=(object); end

  def represent_map(tag, map); end

  def represent_object(tag, obj); end

  def represent_scalar(tag, value); end

  def represent_seq(tag, list); end

  def scalar(*args); end

  def scalar=(value); end

  def seq(); end

  def seq=(list); end

  def style(); end

  def style=(style); end

  def tag(); end

  def tag=(tag); end

  def type(); end
end

class Psych::Coder
end

class Psych::DisallowedClass
  def initialize(klass_name); end
end

class Psych::DisallowedClass
end

class Psych::Emitter
  def alias(_); end

  def canonical(); end

  def canonical=(canonical); end

  def end_document(_); end

  def indentation(); end

  def indentation=(indentation); end

  def initialize(*_); end

  def line_width(); end

  def line_width=(line_width); end

  def scalar(_, _1, _2, _3, _4, _5); end

  def start_document(_, _1, _2); end

  def start_mapping(_, _1, _2, _3); end

  def start_sequence(_, _1, _2, _3); end

  def start_stream(_); end
end

class Psych::Emitter
end

class Psych::Exception
end

class Psych::Exception
end

class Psych::Handler
  def alias(anchor); end

  def empty(); end

  def end_document(implicit); end

  def end_mapping(); end

  def end_sequence(); end

  def end_stream(); end

  def event_location(start_line, start_column, end_line, end_column); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end

  def start_stream(encoding); end

  def streaming?(); end
  EVENTS = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Psych::Handler::DumperOptions
  def canonical(); end

  def canonical=(canonical); end

  def indentation(); end

  def indentation=(indentation); end

  def line_width(); end

  def line_width=(line_width); end
end

class Psych::Handler::DumperOptions
end

class Psych::Handler
end

module Psych::Handlers
end

class Psych::Handlers::DocumentStream
  def initialize(&block); end
end

class Psych::Handlers::DocumentStream
end

module Psych::Handlers
end

module Psych::JSON
end

module Psych::JSON::RubyEvents
  def visit_DateTime(o); end

  def visit_String(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end
end

module Psych::JSON::RubyEvents
end

class Psych::JSON::Stream
  include ::Psych::Streaming
end

class Psych::JSON::Stream::Emitter
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::Stream::Emitter
end

class Psych::JSON::Stream
  extend ::Psych::Streaming::ClassMethods
end

class Psych::JSON::TreeBuilder
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::TreeBuilder
end

module Psych::JSON::YAMLEvents
  def end_document(implicit_end=T.unsafe(nil)); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end
end

module Psych::JSON::YAMLEvents
end

module Psych::JSON
end

module Psych::Nodes
end

class Psych::Nodes::Alias
  def anchor(); end

  def anchor=(anchor); end

  def initialize(anchor); end
end

class Psych::Nodes::Alias
end

class Psych::Nodes::Document
  def implicit(); end

  def implicit=(implicit); end

  def implicit_end(); end

  def implicit_end=(implicit_end); end

  def initialize(version=T.unsafe(nil), tag_directives=T.unsafe(nil), implicit=T.unsafe(nil)); end

  def root(); end

  def tag_directives(); end

  def tag_directives=(tag_directives); end

  def version(); end

  def version=(version); end
end

class Psych::Nodes::Document
end

class Psych::Nodes::Mapping
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Mapping
end

class Psych::Nodes::Node
  include ::Enumerable
  def alias?(); end

  def children(); end

  def document?(); end

  def each(&block); end

  def end_column(); end

  def end_column=(end_column); end

  def end_line(); end

  def end_line=(end_line); end

  def mapping?(); end

  def scalar?(); end

  def sequence?(); end

  def start_column(); end

  def start_column=(start_column); end

  def start_line(); end

  def start_line=(start_line); end

  def stream?(); end

  def tag(); end

  def to_ruby(); end

  def to_yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def transform(); end

  def yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Psych::Nodes::Node
end

class Psych::Nodes::Scalar
  def anchor(); end

  def anchor=(anchor); end

  def initialize(value, anchor=T.unsafe(nil), tag=T.unsafe(nil), plain=T.unsafe(nil), quoted=T.unsafe(nil), style=T.unsafe(nil)); end

  def plain(); end

  def plain=(plain); end

  def quoted(); end

  def quoted=(quoted); end

  def style(); end

  def style=(style); end

  def tag=(tag); end

  def value(); end

  def value=(value); end
  ANY = ::T.let(nil, ::T.untyped)
  DOUBLE_QUOTED = ::T.let(nil, ::T.untyped)
  FOLDED = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  PLAIN = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTED = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Scalar
end

class Psych::Nodes::Sequence
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Sequence
end

class Psych::Nodes::Stream
  def encoding(); end

  def encoding=(encoding); end

  def initialize(encoding=T.unsafe(nil)); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Stream
end

module Psych::Nodes
end

class Psych::Omap
end

class Psych::Omap
end

class Psych::Parser
  def external_encoding=(external_encoding); end

  def handler(); end

  def handler=(handler); end

  def initialize(handler=T.unsafe(nil)); end

  def mark(); end

  def parse(*_); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Parser::Mark
end

class Psych::Parser::Mark
end

class Psych::Parser
end

class Psych::ScalarScanner
  def class_loader(); end

  def initialize(class_loader); end

  def parse_int(string); end

  def parse_time(string); end

  def tokenize(string); end
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  TIME = ::T.let(nil, ::T.untyped)
end

class Psych::ScalarScanner
end

class Psych::Set
end

class Psych::Set
end

class Psych::Stream
  include ::Psych::Streaming
end

class Psych::Stream::Emitter
  def end_document(implicit_end=T.unsafe(nil)); end
end

class Psych::Stream::Emitter
end

class Psych::Stream
  extend ::Psych::Streaming::ClassMethods
end

module Psych::Streaming
  def start(encoding=T.unsafe(nil)); end
end

module Psych::Streaming::ClassMethods
  def new(io); end
end

module Psych::Streaming::ClassMethods
end

module Psych::Streaming
end

class Psych::SyntaxError
  def column(); end

  def context(); end

  def file(); end

  def initialize(file, line, col, offset, problem, context); end

  def line(); end

  def offset(); end

  def problem(); end
end

class Psych::SyntaxError
end

class Psych::TreeBuilder
  def end_document(implicit_end=T.unsafe(nil)); end

  def root(); end
end

class Psych::TreeBuilder
end

module Psych::Visitors
end

class Psych::Visitors::DepthFirst
  def initialize(block); end
end

class Psych::Visitors::DepthFirst
end

class Psych::Visitors::Emitter
  def initialize(io, options=T.unsafe(nil)); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
end

class Psych::Visitors::Emitter
end

class Psych::Visitors::JSONTree
  include ::Psych::JSON::RubyEvents
end

class Psych::Visitors::JSONTree
  def self.create(options=T.unsafe(nil)); end
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::ToRuby
  def class_loader(); end

  def initialize(ss, class_loader); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
  SHOVEL = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::ToRuby
  def self.create(); end
end

class Psych::Visitors::Visitor
  def accept(target); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::Visitor
end

class Psych::Visitors::YAMLTree
  def <<(object); end

  def finish(); end

  def finished(); end

  def finished?(); end

  def initialize(emitter, ss, options); end

  def push(object); end

  def start(encoding=T.unsafe(nil)); end

  def started(); end

  def started?(); end

  def tree(); end

  def visit_Array(o); end

  def visit_BasicObject(o); end

  def visit_BigDecimal(o); end

  def visit_Class(o); end

  def visit_Complex(o); end

  def visit_Date(o); end

  def visit_DateTime(o); end

  def visit_Delegator(o); end

  def visit_Encoding(o); end

  def visit_Enumerator(o); end

  def visit_Exception(o); end

  def visit_FalseClass(o); end

  def visit_Float(o); end

  def visit_Hash(o); end

  def visit_Integer(o); end

  def visit_Module(o); end

  def visit_NameError(o); end

  def visit_NilClass(o); end

  def visit_Object(o); end

  def visit_Psych_Omap(o); end

  def visit_Psych_Set(o); end

  def visit_Range(o); end

  def visit_Rational(o); end

  def visit_Regexp(o); end

  def visit_String(o); end

  def visit_Struct(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end

  def visit_TrueClass(o); end
end

class Psych::Visitors::YAMLTree
  def self.create(options=T.unsafe(nil), emitter=T.unsafe(nil)); end
end

module Psych::Visitors
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.dump_stream(*objects); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.load_file(filename, fallback: T.unsafe(nil)); end

  def self.load_stream(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.parse(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.parse_file(filename, fallback: T.unsafe(nil)); end

  def self.parse_stream(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), &block); end

  def self.parser(); end

  def self.remove_type(type_tag); end

  def self.safe_load(yaml, legacy_permitted_classes=T.unsafe(nil), legacy_permitted_symbols=T.unsafe(nil), legacy_aliases=T.unsafe(nil), legacy_filename=T.unsafe(nil), permitted_classes: T.unsafe(nil), permitted_symbols: T.unsafe(nil), aliases: T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.to_json(object); end
end

module RSpec
  MODULES_TO_AUTOLOAD = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  ADDITIONAL_TOP_LEVEL_FILES = ::T.let(nil, ::T.untyped)
  IGNORE_REGEX = ::T.let(nil, ::T.untyped)
  LIB_REGEX = ::T.let(nil, ::T.untyped)
  RSPEC_LIBS = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  def self.first_non_rspec_line(skip_frames=T.unsafe(nil), increment=T.unsafe(nil)); end
end

module RSpec::Core
end

class RSpec::Core::AnonymousExampleGroup
end

class RSpec::Core::AnonymousExampleGroup
end

class RSpec::Core::BacktraceFormatter
  def backtrace_line(line); end

  def exclude?(line); end

  def exclusion_patterns(); end

  def exclusion_patterns=(exclusion_patterns); end

  def filter_gem(gem_name); end

  def format_backtrace(backtrace, options=T.unsafe(nil)); end

  def full_backtrace=(full_backtrace); end

  def full_backtrace?(); end

  def inclusion_patterns(); end

  def inclusion_patterns=(inclusion_patterns); end
end

class RSpec::Core::BacktraceFormatter
end

class RSpec::Core::Configuration
  include ::RSpec::Core::Hooks
  include ::RSpec::Core::Configuration::Readers
  def add_formatter(formatter, output=T.unsafe(nil)); end

  def add_setting(name, opts=T.unsafe(nil)); end

  def after(scope=T.unsafe(nil), *meta, &block); end

  def alias_example_group_to(new_name, *args); end

  def alias_example_to(name, *args); end

  def alias_it_behaves_like_to(new_name, report_label=T.unsafe(nil)); end

  def alias_it_should_behave_like_to(new_name, report_label=T.unsafe(nil)); end

  def append_after(scope=T.unsafe(nil), *meta, &block); end

  def append_before(scope=T.unsafe(nil), *meta, &block); end

  def apply_derived_metadata_to(metadata); end

  def around(scope=T.unsafe(nil), *meta, &block); end

  def backtrace_exclusion_patterns(); end

  def backtrace_exclusion_patterns=(patterns); end

  def backtrace_formatter(); end

  def backtrace_inclusion_patterns(); end

  def backtrace_inclusion_patterns=(patterns); end

  def before(scope=T.unsafe(nil), *meta, &block); end

  def bisect_runner(); end

  def bisect_runner=(value); end

  def bisect_runner_class(); end

  def color(); end

  def color=(color); end

  def color_enabled?(output=T.unsafe(nil)); end

  def color_mode(); end

  def color_mode=(color_mode); end

  def configure_example(example, example_hooks); end

  def configure_expectation_framework(); end

  def configure_group(group); end

  def configure_mock_framework(); end

  def default_color=(default_color); end

  def default_color?(); end

  def default_formatter(); end

  def default_formatter=(value); end

  def default_path=(path); end

  def default_path?(); end

  def define_derived_metadata(*filters, &block); end

  def deprecation_stream=(value); end

  def detail_color=(detail_color); end

  def detail_color?(); end

  def disable_monkey_patching(); end

  def disable_monkey_patching!(); end

  def disable_monkey_patching=(disable_monkey_patching); end

  def drb=(drb); end

  def drb?(); end

  def drb_port=(drb_port); end

  def drb_port?(); end

  def dry_run=(dry_run); end

  def dry_run?(); end

  def error_stream=(error_stream); end

  def error_stream?(); end

  def example_status_persistence_file_path=(value); end

  def exclude_pattern=(value); end

  def exclusion_filter(); end

  def exclusion_filter=(filter); end

  def expect_with(*frameworks); end

  def expectation_framework=(framework); end

  def expectation_frameworks(); end

  def expose_current_running_example_as(method_name); end

  def expose_dsl_globally=(value); end

  def expose_dsl_globally?(); end

  def extend(mod, *filters); end

  def fail_fast=(value); end

  def fail_if_no_examples=(fail_if_no_examples); end

  def fail_if_no_examples?(); end

  def failure_color=(failure_color); end

  def failure_color?(); end

  def failure_exit_code=(failure_exit_code); end

  def failure_exit_code?(); end

  def files_or_directories_to_run=(*files); end

  def files_to_run(); end

  def files_to_run=(files_to_run); end

  def filter(); end

  def filter=(filter); end

  def filter_gems_from_backtrace(*gem_names); end

  def filter_manager(); end

  def filter_manager=(filter_manager); end

  def filter_run(*args); end

  def filter_run_excluding(*args); end

  def filter_run_including(*args); end

  def filter_run_when_matching(*args); end

  def fixed_color=(fixed_color); end

  def fixed_color?(); end

  def force(hash); end

  def format_docstrings(&block); end

  def format_docstrings_block(); end

  def formatter=(formatter, output=T.unsafe(nil)); end

  def formatter_loader(); end

  def formatters(); end

  def full_backtrace=(true_or_false); end

  def full_backtrace?(); end

  def full_description(); end

  def full_description=(description); end

  def in_project_source_dir_regex(); end

  def include(mod, *filters); end

  def include_context(shared_group_name, *filters); end

  def inclusion_filter(); end

  def inclusion_filter=(filter); end

  def last_run_statuses(); end

  def libs=(libs); end

  def load_spec_files(); end

  def loaded_spec_files(); end

  def max_displayed_failure_line_count=(max_displayed_failure_line_count); end

  def max_displayed_failure_line_count?(); end

  def mock_framework(); end

  def mock_framework=(framework); end

  def mock_with(framework); end

  def on_example_group_definition(&block); end

  def on_example_group_definition_callbacks(); end

  def only_failures?(); end

  def only_failures_but_not_configured?(); end

  def order=(*args, &block); end

  def ordering_manager(); end

  def ordering_registry(*args, &block); end

  def output_stream=(value); end

  def pattern=(value); end

  def pending_color=(pending_color); end

  def pending_color?(); end

  def prepend(mod, *filters); end

  def prepend_after(scope=T.unsafe(nil), *meta, &block); end

  def prepend_before(scope=T.unsafe(nil), *meta, &block); end

  def profile_examples=(profile_examples); end

  def profile_examples?(); end

  def project_source_dirs=(project_source_dirs); end

  def project_source_dirs?(); end

  def raise_errors_for_deprecations!(); end

  def raise_on_warning=(value); end

  def register_ordering(*args, &block); end

  def reporter(); end

  def requires=(paths); end

  def reset(); end

  def reset_filters(); end

  def reset_reporter(); end

  def run_all_when_everything_filtered=(run_all_when_everything_filtered); end

  def run_all_when_everything_filtered?(); end

  def seed(*args, &block); end

  def seed=(*args, &block); end

  def seed_used?(*args, &block); end

  def shared_context_metadata_behavior=(value); end

  def silence_filter_announcements=(silence_filter_announcements); end

  def silence_filter_announcements?(); end

  def spec_files_with_failures(); end

  def start_time=(start_time); end

  def start_time?(); end

  def static_config_filter_manager(); end

  def static_config_filter_manager=(static_config_filter_manager); end

  def success_color=(success_color); end

  def success_color?(); end

  def threadsafe=(threadsafe); end

  def threadsafe?(); end

  def treat_symbols_as_metadata_keys_with_true_values=(_value); end

  def tty=(tty); end

  def tty?(); end

  def warnings=(value); end

  def warnings?(); end

  def when_first_matching_example_defined(*filters); end

  def with_suite_hooks(); end

  def world(); end

  def world=(world); end
  DEFAULT_FORMATTER = ::T.let(nil, ::T.untyped)
  FAILED_STATUS = ::T.let(nil, ::T.untyped)
  MOCKING_ADAPTERS = ::T.let(nil, ::T.untyped)
  PASSED_STATUS = ::T.let(nil, ::T.untyped)
  PENDING_STATUS = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  UNKNOWN_STATUS = ::T.let(nil, ::T.untyped)
  VALID_STATUSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Configuration::DeprecationReporterBuffer
  def deprecation(*args); end

  def play_onto(reporter); end
end

class RSpec::Core::Configuration::DeprecationReporterBuffer
end

module RSpec::Core::Configuration::ExposeCurrentExample
end

module RSpec::Core::Configuration::ExposeCurrentExample
end

class RSpec::Core::Configuration::MustBeConfiguredBeforeExampleGroupsError
end

class RSpec::Core::Configuration::MustBeConfiguredBeforeExampleGroupsError
end

module RSpec::Core::Configuration::Readers
  def default_color(); end

  def default_path(); end

  def deprecation_stream(); end

  def detail_color(); end

  def drb(); end

  def drb_port(); end

  def dry_run(); end

  def error_stream(); end

  def example_status_persistence_file_path(); end

  def exclude_pattern(); end

  def fail_fast(); end

  def fail_if_no_examples(); end

  def failure_color(); end

  def failure_exit_code(); end

  def fixed_color(); end

  def libs(); end

  def max_displayed_failure_line_count(); end

  def only_failures(); end

  def output_stream(); end

  def pattern(); end

  def pending_color(); end

  def profile_examples(); end

  def project_source_dirs(); end

  def requires(); end

  def run_all_when_everything_filtered(); end

  def shared_context_metadata_behavior(); end

  def silence_filter_announcements(); end

  def start_time(); end

  def success_color(); end

  def threadsafe(); end

  def tty(); end
end

module RSpec::Core::Configuration::Readers
end

class RSpec::Core::Configuration
  def self.add_read_only_setting(name, opts=T.unsafe(nil)); end

  def self.add_setting(name, opts=T.unsafe(nil)); end

  def self.define_aliases(name, alias_name); end

  def self.define_predicate_for(*names); end

  def self.define_reader(name); end

  def self.delegate_to_ordering_manager(*methods); end
end

class RSpec::Core::ConfigurationOptions
  def args(); end

  def configure(config); end

  def configure_filter_manager(filter_manager); end

  def initialize(args); end

  def options(); end
  OPTIONS_ORDER = ::T.let(nil, ::T.untyped)
  UNFORCED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNPROCESSABLE_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ConfigurationOptions
end

module RSpec::Core::DSL
end

module RSpec::Core::DSL
  def self.change_global_dsl(&changes); end

  def self.example_group_aliases(); end

  def self.expose_example_group_alias(name); end

  def self.expose_example_group_alias_globally(method_name); end

  def self.expose_globally!(); end

  def self.exposed_globally?(); end

  def self.remove_globally!(); end

  def self.top_level(); end

  def self.top_level=(top_level); end
end

class RSpec::Core::DeprecationError
end

class RSpec::Core::DeprecationError
end

class RSpec::Core::DidYouMean
  def call(); end

  def initialize(relative_file_name); end

  def relative_file_name(); end
end

class RSpec::Core::DidYouMean
end

class RSpec::Core::Example
  def clock(); end

  def clock=(clock); end

  def description(); end

  def display_exception(); end

  def display_exception=(ex); end

  def duplicate_with(metadata_overrides=T.unsafe(nil)); end

  def example_group(); end

  def example_group_instance(); end

  def exception(); end

  def execution_result(); end

  def fail_with_exception(reporter, exception); end

  def file_path(); end

  def full_description(); end

  def id(); end

  def initialize(example_group_class, description, user_metadata, example_block=T.unsafe(nil)); end

  def inspect_output(); end

  def instance_exec(*args, &block); end

  def location(); end

  def location_rerun_argument(); end

  def metadata(); end

  def pending(); end

  def pending?(); end

  def reporter(); end

  def rerun_argument(); end

  def run(example_group_instance, reporter); end

  def set_aggregate_failures_exception(exception); end

  def set_exception(exception); end

  def skip(); end

  def skip_with_exception(reporter, exception); end

  def skipped?(); end

  def update_inherited_metadata(updates); end
end

RSpec::Core::Example::AllExceptionsExcludingDangerousOnesOnRubiesThatAllowIt = RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue

class RSpec::Core::Example::ExecutionResult
  include ::RSpec::Core::HashImitatable
  def ensure_timing_set(clock); end

  def example_skipped?(); end

  def exception(); end

  def exception=(exception); end

  def finished_at(); end

  def finished_at=(finished_at); end

  def pending_exception(); end

  def pending_exception=(pending_exception); end

  def pending_fixed(); end

  def pending_fixed=(pending_fixed); end

  def pending_fixed?(); end

  def pending_message(); end

  def pending_message=(pending_message); end

  def record_finished(status, finished_at); end

  def run_time(); end

  def run_time=(run_time); end

  def started_at(); end

  def started_at=(started_at); end

  def status(); end

  def status=(status); end
end

class RSpec::Core::Example::ExecutionResult
  extend ::RSpec::Core::HashImitatable::ClassMethods
end

class RSpec::Core::Example::Procsy
  def <<(*a, &b); end

  def ===(*a, &b); end

  def >>(*a, &b); end

  def [](*a, &b); end

  def arity(*a, &b); end

  def binding(*a, &b); end

  def call(*args, &block); end

  def clock(*a, &b); end

  def clock=(*a, &b); end

  def clone(*a, &b); end

  def curry(*a, &b); end

  def description(*a, &b); end

  def dup(*a, &b); end

  def duplicate_with(*a, &b); end

  def example(); end

  def example_group(*a, &b); end

  def example_group_instance(*a, &b); end

  def exception(*a, &b); end

  def executed?(); end

  def execution_result(*a, &b); end

  def file_path(*a, &b); end

  def full_description(*a, &b); end

  def hash(*a, &b); end

  def id(*a, &b); end

  def initialize(example, &block); end

  def inspect_output(*a, &b); end

  def lambda?(*a, &b); end

  def location(*a, &b); end

  def location_rerun_argument(*a, &b); end

  def metadata(*a, &b); end

  def parameters(*a, &b); end

  def pending(*a, &b); end

  def pending?(*a, &b); end

  def reporter(*a, &b); end

  def rerun_argument(*a, &b); end

  def run(*args, &block); end

  def skip(*a, &b); end

  def skipped?(*a, &b); end

  def source_location(*a, &b); end

  def to_proc(); end

  def update_inherited_metadata(*a, &b); end

  def wrap(&block); end

  def yield(*a, &b); end
end

class RSpec::Core::Example::Procsy
end

class RSpec::Core::Example
  def self.delegate_to_metadata(key); end

  def self.parse_id(id); end
end

class RSpec::Core::ExampleGroup
  include ::RSpec::Core::MemoizedHelpers
  include ::RSpec::Core::Pending
  include ::RSpec::Core::MockingAdapters::RSpec
  include ::RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  include ::RSpec::Mocks::ExampleMethods::ExpectHost
  include ::RSpec::Matchers
  def described_class(); end

  def initialize(inspect_output=T.unsafe(nil)); end
  INSTANCE_VARIABLE_TO_IGNORE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ExampleGroup::WrongScopeError
end

class RSpec::Core::ExampleGroup::WrongScopeError
end

class RSpec::Core::ExampleGroup
  extend ::RSpec::Core::Hooks
  extend ::RSpec::Core::MemoizedHelpers::ClassMethods
  extend ::RSpec::Core::SharedExampleGroup
  def self.add_example(example); end

  def self.before_context_ivars(); end

  def self.children(); end

  def self.context(*args, &example_group_block); end

  def self.currently_executing_a_context_hook?(); end

  def self.declaration_locations(); end

  def self.define_example_group_method(name, metadata=T.unsafe(nil)); end

  def self.define_example_method(name, extra_options=T.unsafe(nil)); end

  def self.define_nested_shared_group_method(new_name, report_label=T.unsafe(nil)); end

  def self.delegate_to_metadata(*names); end

  def self.descendant_filtered_examples(); end

  def self.descendants(); end

  def self.describe(*args, &example_group_block); end

  def self.described_class(); end

  def self.description(); end

  def self.each_instance_variable_for_example(group); end

  def self.ensure_example_groups_are_configured(); end

  def self.example(*all_args, &block); end

  def self.example_group(*args, &example_group_block); end

  def self.examples(); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.fexample(*all_args, &block); end

  def self.file_path(); end

  def self.filtered_examples(); end

  def self.find_and_eval_shared(label, name, inclusion_location, *args, &customization_block); end

  def self.fit(*all_args, &block); end

  def self.focus(*all_args, &block); end

  def self.for_filtered_examples(reporter, &block); end

  def self.fspecify(*all_args, &block); end

  def self.id(); end

  def self.idempotently_define_singleton_method(name, &definition); end

  def self.include_context(name, *args, &block); end

  def self.include_examples(name, *args, &block); end

  def self.it(*all_args, &block); end

  def self.it_behaves_like(name, *args, &customization_block); end

  def self.it_should_behave_like(name, *args, &customization_block); end

  def self.location(); end

  def self.metadata(); end

  def self.next_runnable_index_for(file); end

  def self.ordering_strategy(); end

  def self.parent_groups(); end

  def self.pending(*all_args, &block); end

  def self.remove_example(example); end

  def self.reset_memoized(); end

  def self.run(reporter=T.unsafe(nil)); end

  def self.run_after_context_hooks(example_group_instance); end

  def self.run_before_context_hooks(example_group_instance); end

  def self.run_examples(reporter); end

  def self.set_it_up(description, args, registration_collection, &example_group_block); end

  def self.set_ivars(instance, ivars); end

  def self.skip(*all_args, &block); end

  def self.specify(*all_args, &block); end

  def self.store_before_context_ivars(example_group_instance); end

  def self.subclass(parent, description, args, registration_collection, &example_group_block); end

  def self.superclass_before_context_ivars(); end

  def self.superclass_metadata(); end

  def self.top_level?(); end

  def self.top_level_description(); end

  def self.traverse_tree_until(&block); end

  def self.update_inherited_metadata(updates); end

  def self.with_replaced_metadata(meta); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end

  def self.xexample(*all_args, &block); end

  def self.xit(*all_args, &block); end

  def self.xspecify(*all_args, &block); end
end

class RSpec::Core::ExampleStatusPersister
  def initialize(examples, file_name); end

  def persist(); end
end

class RSpec::Core::ExampleStatusPersister
  def self.load_from(file_name); end

  def self.persist(examples, file_name); end
end

RSpec::Core::ExclusionRules = RSpec::Core::FilterRules

class RSpec::Core::FilterManager
  def add_ids(rerun_path, scoped_ids); end

  def add_location(file_path, line_numbers); end

  def empty?(); end

  def exclude(*args); end

  def exclude_only(*args); end

  def exclude_with_low_priority(*args); end

  def exclusions(); end

  def include(*args); end

  def include_only(*args); end

  def include_with_low_priority(*args); end

  def inclusions(); end

  def prune(examples); end
end

class RSpec::Core::FilterManager
end

class RSpec::Core::FilterRules
  def [](key); end

  def add(updated); end

  def add_with_low_priority(updated); end

  def clear(); end

  def delete(key); end

  def description(); end

  def each_pair(&block); end

  def empty?(); end

  def fetch(*args, &block); end

  def include_example?(example); end

  def initialize(rules=T.unsafe(nil)); end

  def opposite(); end

  def opposite=(opposite); end

  def rules(); end

  def use_only(updated); end
  PROC_HEX_NUMBER = ::T.let(nil, ::T.untyped)
  PROJECT_DIR = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::FilterRules
  def self.build(); end
end

module RSpec::Core::FilterableItemRepository
end

class RSpec::Core::FilterableItemRepository::QueryOptimized
  def items_for(metadata); end
end

class RSpec::Core::FilterableItemRepository::QueryOptimized
end

class RSpec::Core::FilterableItemRepository::UpdateOptimized
  def append(item, metadata); end

  def delete(item, metadata); end

  def initialize(applies_predicate); end

  def items_and_filters(); end

  def items_for(request_meta); end

  def prepend(item, metadata); end
end

class RSpec::Core::FilterableItemRepository::UpdateOptimized
end

module RSpec::Core::FilterableItemRepository
end

module RSpec::Core::FlatMap
end

module RSpec::Core::FlatMap
  def self.flat_map(array, &block); end
end

module RSpec::Core::Formatters
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def example_failed(notification); end

  def example_finished(notification); end

  def initialize(expected_failures); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def self.inherited(formatter); end
end

class RSpec::Core::Formatters::BaseFormatter
  def close(_notification); end

  def example_group(); end

  def example_group=(example_group); end

  def example_group_started(notification); end

  def initialize(output); end

  def output(); end

  def start(notification); end
end

class RSpec::Core::Formatters::BaseFormatter
end

class RSpec::Core::Formatters::BaseTextFormatter
  def dump_failures(notification); end

  def dump_pending(notification); end

  def dump_summary(summary); end

  def message(notification); end

  def seed(notification); end
end

class RSpec::Core::Formatters::BaseTextFormatter
end

class RSpec::Core::Formatters::BisectDRbFormatter
  def initialize(_output); end

  def notify_results(results); end
end

class RSpec::Core::Formatters::BisectDRbFormatter
end

module RSpec::Core::Formatters::ConsoleCodes
  VT100_CODES = ::T.let(nil, ::T.untyped)
  VT100_CODE_VALUES = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::ConsoleCodes
  def self.config_colors_to_methods(); end

  def self.console_code_for(code_or_symbol); end

  def self.wrap(text, code_or_symbol); end
end

class RSpec::Core::Formatters::DeprecationFormatter
  def count(); end

  def deprecation(notification); end

  def deprecation_message_for(data); end

  def deprecation_stream(); end

  def deprecation_summary(_notification); end

  def initialize(deprecation_stream, summary_stream); end

  def output(); end

  def printer(); end

  def summary_stream(); end
  DEPRECATION_STREAM_NOTICE = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_CONFIG_NOTICE = ::T.let(nil, ::T.untyped)
  TOO_MANY_WARNINGS_NOTICE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
  def deprecation_formatter(); end

  def deprecation_stream(); end

  def deprecation_summary(); end

  def initialize(deprecation_stream, summary_stream, deprecation_formatter); end

  def print_deferred_deprecation_warnings(); end

  def print_deprecation_message(data); end

  def stash_deprecation_message(deprecation_message); end

  def summary_stream(); end
  TOO_MANY_USES_LIMIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
end

class RSpec::Core::Formatters::DeprecationFormatter::FileStream
  def initialize(file); end

  def puts(*args); end

  def summarize(summary_stream, deprecation_count); end
end

class RSpec::Core::Formatters::DeprecationFormatter::FileStream
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage
  def initialize(data); end

  def too_many_warnings_message(); end

  def type(); end

  def type=(_); end
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Formatters::DeprecationFormatter::ImmediatePrinter
  def deprecation_formatter(); end

  def deprecation_stream(); end

  def deprecation_summary(); end

  def initialize(deprecation_stream, summary_stream, deprecation_formatter); end

  def print_deprecation_message(data); end

  def summary_stream(); end
end

class RSpec::Core::Formatters::DeprecationFormatter::ImmediatePrinter
end

class RSpec::Core::Formatters::DeprecationFormatter::RaiseErrorStream
  def puts(message); end

  def summarize(summary_stream, deprecation_count); end
end

class RSpec::Core::Formatters::DeprecationFormatter::RaiseErrorStream
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage
  def initialize(data); end

  def too_many_warnings_message(); end

  def type(); end

  def type=(_); end
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Formatters::DeprecationFormatter
end

class RSpec::Core::Formatters::DocumentationFormatter
  def example_failed(failure); end

  def example_group_finished(_notification); end

  def example_passed(passed); end

  def example_pending(pending); end

  def example_started(_notification); end
end

class RSpec::Core::Formatters::DocumentationFormatter
end

class RSpec::Core::Formatters::ExceptionPresenter
  def colorized_formatted_backtrace(colorizer=T.unsafe(nil)); end

  def colorized_message_lines(colorizer=T.unsafe(nil)); end

  def description(); end

  def example(); end

  def exception(); end

  def formatted_backtrace(exception=T.unsafe(nil)); end

  def formatted_cause(exception); end

  def fully_formatted(failure_number, colorizer=T.unsafe(nil)); end

  def fully_formatted_lines(failure_number, colorizer); end

  def initialize(exception, example, options=T.unsafe(nil)); end

  def message_lines(); end
  PENDING_DETAIL_FORMATTER = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory
  def build(); end

  def initialize(example); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory::CommonBacktraceTruncater
  def initialize(parent); end

  def with_truncated_backtrace(child); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory::CommonBacktraceTruncater
end

module RSpec::Core::Formatters::ExceptionPresenter::Factory::EmptyBacktraceFormatter
end

module RSpec::Core::Formatters::ExceptionPresenter::Factory::EmptyBacktraceFormatter
  def self.format_backtrace(*_); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory
end

class RSpec::Core::Formatters::ExceptionPresenter
end

class RSpec::Core::Formatters::FailureListFormatter
  def dump_profile(_profile); end

  def example_failed(failure); end

  def message(_message); end
end

class RSpec::Core::Formatters::FailureListFormatter
end

class RSpec::Core::Formatters::FallbackMessageFormatter
  def initialize(output); end

  def message(notification); end

  def output(); end
end

class RSpec::Core::Formatters::FallbackMessageFormatter
end

module RSpec::Core::Formatters::Helpers
  DEFAULT_PRECISION = ::T.let(nil, ::T.untyped)
  SUB_SECOND_PRECISION = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::Helpers
  def self.format_duration(duration); end

  def self.format_seconds(float, precision=T.unsafe(nil)); end

  def self.organize_ids(ids); end

  def self.pluralize(count, string); end
end

class RSpec::Core::Formatters::HtmlFormatter
  def dump_summary(summary); end

  def example_failed(failure); end

  def example_passed(passed); end

  def example_pending(pending); end

  def example_started(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::HtmlFormatter
end

class RSpec::Core::Formatters::JsonFormatter
  def dump_profile(profile); end

  def dump_profile_slowest_example_groups(profile); end

  def dump_profile_slowest_examples(profile); end

  def dump_summary(summary); end

  def message(notification); end

  def output_hash(); end

  def seed(notification); end

  def stop(notification); end
end

class RSpec::Core::Formatters::JsonFormatter
end

class RSpec::Core::Formatters::Loader
  def add(formatter_to_use, *paths); end

  def default_formatter(); end

  def default_formatter=(default_formatter); end

  def formatters(); end

  def initialize(reporter); end

  def prepare_default(output_stream, deprecation_stream); end

  def reporter(); end

  def setup_default(output_stream, deprecation_stream); end
end

class RSpec::Core::Formatters::Loader
  def self.formatters(); end
end

class RSpec::Core::Formatters::ProfileFormatter
  def dump_profile(profile); end

  def initialize(output); end

  def output(); end
end

class RSpec::Core::Formatters::ProfileFormatter
end

class RSpec::Core::Formatters::ProgressFormatter
  def example_failed(_notification); end

  def example_passed(_notification); end

  def example_pending(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::ProgressFormatter
end

class RSpec::Core::Formatters::SnippetExtractor
  def beginning_line_number(); end

  def expression_lines(); end

  def initialize(source, beginning_line_number, max_line_count=T.unsafe(nil)); end

  def max_line_count(); end

  def source(); end
end

class RSpec::Core::Formatters::SnippetExtractor::NoExpressionAtLineError
end

class RSpec::Core::Formatters::SnippetExtractor::NoExpressionAtLineError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchFileError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchFileError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchLineError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchLineError
end

class RSpec::Core::Formatters::SnippetExtractor
  def self.extract_expression_lines_at(file_path, beginning_line_number, max_line_count=T.unsafe(nil)); end

  def self.extract_line_at(file_path, line_number); end

  def self.least_indentation_from(lines); end

  def self.source_from_file(path); end
end

class RSpec::Core::Formatters::SyntaxHighlighter
  def highlight(lines); end

  def initialize(configuration); end
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  RESET_CODE = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  def self.highlight_syntax(lines); end
end

module RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation
end

module RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation
  def self.highlight_syntax(lines); end
end

RSpec::Core::Formatters::SyntaxHighlighter::WindowsImplementation = RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation

class RSpec::Core::Formatters::SyntaxHighlighter
  def self.attempt_to_add_rspec_terms_to_coderay_keywords(); end
end

module RSpec::Core::Formatters
  def self.register(formatter_class, *notifications); end
end

module RSpec::Core::HashImitatable
  def <(*args, &block); end

  def <=(*args, &block); end

  def >(*args, &block); end

  def >=(*args, &block); end

  def [](key); end

  def []=(key, value); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def assoc(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect_concat(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def compare_by_identity(*args, &block); end

  def compare_by_identity?(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def default(*args, &block); end

  def default=(*args, &block); end

  def default_proc(*args, &block); end

  def default_proc=(*args, &block); end

  def delete(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_key(*args, &block); end

  def each_pair(*args, &block); end

  def each_slice(*args, &block); end

  def each_value(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def fetch(*args, &block); end

  def fetch_values(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def has_key?(*args, &block); end

  def has_value?(*args, &block); end

  def include?(*args, &block); end

  def index(*args, &block); end

  def inject(*args, &block); end

  def invert(*args, &block); end

  def keep_if(*args, &block); end

  def key(*args, &block); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def map(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def merge(*args, &block); end

  def merge!(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def partition(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def rehash(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def replace(*args, &block); end

  def reverse_each(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shift(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort_by(*args, &block); end

  def store(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def to_a(*args, &block); end

  def to_h(); end

  def to_hash(*args, &block); end

  def to_proc(*args, &block); end

  def to_set(*args, &block); end

  def transform_keys(*args, &block); end

  def transform_keys!(*args, &block); end

  def transform_values(*args, &block); end

  def transform_values!(*args, &block); end

  def uniq(*args, &block); end

  def update(*args, &block); end

  def value?(*args, &block); end

  def values(*args, &block); end

  def values_at(*args, &block); end

  def zip(*args, &block); end
end

module RSpec::Core::HashImitatable::ClassMethods
  def attr_accessor(*names); end

  def hash_attribute_names(); end
end

module RSpec::Core::HashImitatable::ClassMethods
end

module RSpec::Core::HashImitatable
  def self.included(klass); end
end

module RSpec::Core::Hooks
  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def hooks(); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end
end

class RSpec::Core::Hooks::AfterContextHook
  def run(example); end
end

class RSpec::Core::Hooks::AfterContextHook
end

class RSpec::Core::Hooks::AfterHook
  def run(example); end
end

class RSpec::Core::Hooks::AfterHook
end

class RSpec::Core::Hooks::AroundHook
  def execute_with(example, procsy); end

  def hook_description(); end
end

class RSpec::Core::Hooks::AroundHook
end

class RSpec::Core::Hooks::BeforeHook
  def run(example); end
end

class RSpec::Core::Hooks::BeforeHook
end

class RSpec::Core::Hooks::Hook
  def block(); end

  def block=(_); end

  def options(); end

  def options=(_); end
end

class RSpec::Core::Hooks::Hook
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Hooks::HookCollections
  def all_hooks_for(position, scope); end

  def initialize(owner, filterable_item_repo_class); end

  def matching_hooks_for(position, scope, example_or_group); end

  def processable_hooks_for(position, scope, host); end

  def register(prepend_or_append, position, *args, &block); end

  def register_global_singleton_context_hooks(example, globals); end

  def register_globals(host, globals); end

  def run(position, scope, example_or_group); end

  def run_owned_hooks_for(position, scope, example_or_group); end
  EMPTY_HOOK_ARRAY = ::T.let(nil, ::T.untyped)
  HOOK_TYPES = ::T.let(nil, ::T.untyped)
  SCOPES = ::T.let(nil, ::T.untyped)
  SCOPE_ALIASES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Hooks::HookCollections
end

module RSpec::Core::Hooks
end

class RSpec::Core::InclusionRules
  def add(*args); end

  def add_with_low_priority(*args); end

  def split_file_scoped_rules(); end

  def standalone?(); end
end

class RSpec::Core::InclusionRules
end

module RSpec::Core::Invocations
end

class RSpec::Core::Invocations::Bisect
  def call(options, err, out); end
end

class RSpec::Core::Invocations::Bisect
end

class RSpec::Core::Invocations::DRbWithFallback
  def call(options, err, out); end
end

class RSpec::Core::Invocations::DRbWithFallback
end

class RSpec::Core::Invocations::InitializeProject
  def call(*_args); end
end

class RSpec::Core::Invocations::InitializeProject
end

class RSpec::Core::Invocations::PrintHelp
  def call(_options, _err, out); end

  def hidden_options(); end

  def hidden_options=(_); end

  def parser(); end

  def parser=(_); end
end

class RSpec::Core::Invocations::PrintHelp
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Invocations::PrintVersion
  def call(_options, _err, out); end
end

class RSpec::Core::Invocations::PrintVersion
end

module RSpec::Core::Invocations
end

class RSpec::Core::LegacyExampleGroupHash
  include ::RSpec::Core::HashImitatable
  def initialize(metadata); end
end

class RSpec::Core::LegacyExampleGroupHash
  extend ::RSpec::Core::HashImitatable::ClassMethods
end

module RSpec::Core::MemoizedHelpers
  def initialize(*_); end

  def is_expected(); end

  def should(matcher=T.unsafe(nil), message=T.unsafe(nil)); end

  def should_not(matcher=T.unsafe(nil), message=T.unsafe(nil)); end

  def subject(); end
end

module RSpec::Core::MemoizedHelpers::ClassMethods
  def let(name, &block); end

  def let!(name, &block); end

  def subject(name=T.unsafe(nil), &block); end

  def subject!(name=T.unsafe(nil), &block); end
end

module RSpec::Core::MemoizedHelpers::ClassMethods
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::After
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::After
  def self.article(); end

  def self.hook_expression(); end

  def self.hook_intention(); end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::Before
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::Before
  def self.article(); end

  def self.hook_expression(); end

  def self.hook_intention(); end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized
  def self.fetch_or_store(key, &_block); end

  def self.isolate_for_context_hook(example_group_instance); end
end

class RSpec::Core::MemoizedHelpers::NonThreadSafeMemoized
  def fetch_or_store(key); end
end

class RSpec::Core::MemoizedHelpers::NonThreadSafeMemoized
end

class RSpec::Core::MemoizedHelpers::ThreadsafeMemoized
  def fetch_or_store(key); end
end

class RSpec::Core::MemoizedHelpers::ThreadsafeMemoized
end

module RSpec::Core::MemoizedHelpers
  def self.define_helpers_on(example_group); end

  def self.get_constant_or_yield(example_group, name); end

  def self.module_for(example_group); end
end

module RSpec::Core::Metadata
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Metadata::ExampleGroupHash
end

class RSpec::Core::Metadata::ExampleGroupHash
  def self.backwards_compatibility_default_proc(&example_group_selector); end

  def self.create(parent_group_metadata, user_metadata, example_group_index, *args, &block); end

  def self.hash_with_backwards_compatibility_default_proc(); end
end

class RSpec::Core::Metadata::ExampleHash
end

class RSpec::Core::Metadata::ExampleHash
  def self.create(group_metadata, user_metadata, index_provider, description, block); end
end

class RSpec::Core::Metadata::HashPopulator
  def block(); end

  def description_args(); end

  def initialize(metadata, user_metadata, index_provider, description_args, block); end

  def metadata(); end

  def populate(); end

  def user_metadata(); end
end

class RSpec::Core::Metadata::HashPopulator
end

module RSpec::Core::Metadata
  def self.ascend(metadata); end

  def self.ascending(metadata); end

  def self.build_hash_from(args, warn_about_example_group_filtering=T.unsafe(nil)); end

  def self.deep_hash_dup(object); end

  def self.id_from(metadata); end

  def self.location_tuple_from(metadata); end

  def self.relative_path(line); end

  def self.relative_path_regex(); end
end

module RSpec::Core::MetadataFilter
end

module RSpec::Core::MetadataFilter
  def self.apply?(predicate, filters, metadata); end

  def self.filter_applies?(key, filter_value, metadata); end

  def self.silence_metadata_example_group_deprecations(); end
end

module RSpec::Core::MockingAdapters
end

module RSpec::Core::MockingAdapters::RSpec
  include ::RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  include ::RSpec::Mocks::ExampleMethods::ExpectHost
  def setup_mocks_for_rspec(); end

  def teardown_mocks_for_rspec(); end

  def verify_mocks_for_rspec(); end
end

module RSpec::Core::MockingAdapters::RSpec
  def self.configuration(); end

  def self.framework_name(); end
end

module RSpec::Core::MockingAdapters
end

class RSpec::Core::MultipleExceptionError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
  def aggregation_block_label(); end

  def aggregation_metadata(); end

  def all_exceptions(); end

  def exception_count_description(); end

  def failures(); end

  def initialize(*exceptions); end

  def other_errors(); end

  def summary(); end
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  def add(exception); end
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  def self.for(ex); end
end

class RSpec::Core::MultipleExceptionError
end

module RSpec::Core::Notifications
end

class RSpec::Core::Notifications::CustomNotification
end

class RSpec::Core::Notifications::CustomNotification
  def self.for(options=T.unsafe(nil)); end
end

class RSpec::Core::Notifications::DeprecationNotification
  def call_site(); end

  def call_site=(_); end

  def deprecated(); end

  def deprecated=(_); end

  def message(); end

  def message=(_); end

  def replacement(); end

  def replacement=(_); end
end

class RSpec::Core::Notifications::DeprecationNotification
  def self.[](*_); end

  def self.from_hash(data); end

  def self.members(); end
end

class RSpec::Core::Notifications::ExampleNotification
  def example(); end

  def example=(_); end
end

class RSpec::Core::Notifications::ExampleNotification
  def self.[](*_); end

  def self.for(example); end

  def self.members(); end
end

class RSpec::Core::Notifications::ExamplesNotification
  def examples(); end

  def failed_examples(); end

  def failure_notifications(); end

  def fully_formatted_failed_examples(colorizer=T.unsafe(nil)); end

  def fully_formatted_pending_examples(colorizer=T.unsafe(nil)); end

  def initialize(reporter); end

  def notifications(); end

  def pending_examples(); end

  def pending_notifications(); end
end

class RSpec::Core::Notifications::ExamplesNotification
end

class RSpec::Core::Notifications::FailedExampleNotification
  def colorized_formatted_backtrace(colorizer=T.unsafe(nil)); end

  def colorized_message_lines(colorizer=T.unsafe(nil)); end

  def description(); end

  def exception(); end

  def formatted_backtrace(); end

  def fully_formatted(failure_number, colorizer=T.unsafe(nil)); end

  def fully_formatted_lines(failure_number, colorizer=T.unsafe(nil)); end

  def initialize(example, exception_presenter=T.unsafe(nil)); end

  def message_lines(); end
end

class RSpec::Core::Notifications::FailedExampleNotification
end

class RSpec::Core::Notifications::GroupNotification
  def group(); end

  def group=(_); end
end

class RSpec::Core::Notifications::GroupNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::MessageNotification
  def message(); end

  def message=(_); end
end

class RSpec::Core::Notifications::MessageNotification
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::Notifications::NullColorizer
end

module RSpec::Core::Notifications::NullColorizer
  def self.wrap(line, _code_or_symbol); end
end

class RSpec::Core::Notifications::NullNotification
end

class RSpec::Core::Notifications::NullNotification
end

class RSpec::Core::Notifications::PendingExampleFailedAsExpectedNotification
end

class RSpec::Core::Notifications::PendingExampleFailedAsExpectedNotification
end

class RSpec::Core::Notifications::PendingExampleFixedNotification
end

class RSpec::Core::Notifications::PendingExampleFixedNotification
end

class RSpec::Core::Notifications::ProfileNotification
  def duration(); end

  def examples(); end

  def initialize(duration, examples, number_of_examples, example_groups); end

  def number_of_examples(); end

  def percentage(); end

  def slow_duration(); end

  def slowest_examples(); end

  def slowest_groups(); end
end

class RSpec::Core::Notifications::ProfileNotification
end

class RSpec::Core::Notifications::SeedNotification
  def fully_formatted(); end

  def seed(); end

  def seed=(_); end

  def seed_used?(); end

  def used=(_); end
end

class RSpec::Core::Notifications::SeedNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::SkippedExampleNotification
  def fully_formatted(pending_number, colorizer=T.unsafe(nil)); end
end

class RSpec::Core::Notifications::SkippedExampleNotification
end

class RSpec::Core::Notifications::StartNotification
  def count(); end

  def count=(_); end

  def load_time(); end

  def load_time=(_); end
end

class RSpec::Core::Notifications::StartNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::SummaryNotification
  include ::RSpec::Core::ShellEscape
  def colorized_rerun_commands(colorizer=T.unsafe(nil)); end

  def colorized_totals_line(colorizer=T.unsafe(nil)); end

  def duration(); end

  def duration=(_); end

  def errors_outside_of_examples_count(); end

  def errors_outside_of_examples_count=(_); end

  def example_count(); end

  def examples(); end

  def examples=(_); end

  def failed_examples(); end

  def failed_examples=(_); end

  def failure_count(); end

  def formatted_duration(); end

  def formatted_load_time(); end

  def fully_formatted(colorizer=T.unsafe(nil)); end

  def load_time(); end

  def load_time=(_); end

  def pending_count(); end

  def pending_examples(); end

  def pending_examples=(_); end

  def totals_line(); end
end

class RSpec::Core::Notifications::SummaryNotification
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::Notifications
end

class RSpec::Core::NullReporter
end

class RSpec::Core::NullReporter
end

module RSpec::Core::Ordering
end

class RSpec::Core::Ordering::ConfigurationManager
  def force(hash); end

  def order=(type); end

  def ordering_registry(); end

  def register_ordering(name, strategy=T.unsafe(nil)); end

  def seed(); end

  def seed=(seed); end

  def seed_used?(); end
end

class RSpec::Core::Ordering::ConfigurationManager
end

class RSpec::Core::Ordering::Custom
  def initialize(callable); end

  def order(list); end
end

class RSpec::Core::Ordering::Custom
end

class RSpec::Core::Ordering::Identity
  def order(items); end
end

class RSpec::Core::Ordering::Identity
end

class RSpec::Core::Ordering::Random
  def initialize(configuration); end

  def order(items); end

  def used?(); end
  MAX_32_BIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Ordering::Random
end

class RSpec::Core::Ordering::Registry
  def fetch(name, &fallback); end

  def initialize(configuration); end

  def register(sym, strategy); end

  def used_random_seed?(); end
end

class RSpec::Core::Ordering::Registry
end

module RSpec::Core::Ordering
end

class RSpec::Core::OutputWrapper
  def <<(*args, &block); end

  def advise(*args, &block); end

  def autoclose=(*args, &block); end

  def autoclose?(*args, &block); end

  def binmode(*args, &block); end

  def binmode?(*args, &block); end

  def bytes(*args, &block); end

  def chars(*args, &block); end

  def close(*args, &block); end

  def close_on_exec=(*args, &block); end

  def close_on_exec?(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def codepoints(*args, &block); end

  def each(*args, &block); end

  def each_byte(*args, &block); end

  def each_char(*args, &block); end

  def each_codepoint(*args, &block); end

  def each_line(*args, &block); end

  def eof(*args, &block); end

  def eof?(*args, &block); end

  def external_encoding(*args, &block); end

  def fcntl(*args, &block); end

  def fdatasync(*args, &block); end

  def fileno(*args, &block); end

  def flush(*args, &block); end

  def fsync(*args, &block); end

  def getbyte(*args, &block); end

  def getc(*args, &block); end

  def gets(*args, &block); end

  def initialize(output); end

  def inspect(*args, &block); end

  def internal_encoding(*args, &block); end

  def ioctl(*args, &block); end

  def isatty(*args, &block); end

  def lineno(*args, &block); end

  def lineno=(*args, &block); end

  def lines(*args, &block); end

  def method_missing(name, *args, &block); end

  def nonblock(*args, &block); end

  def nonblock=(*args, &block); end

  def nonblock?(*args, &block); end

  def nread(*args, &block); end

  def output(); end

  def output=(output); end

  def pathconf(*args, &block); end

  def pid(*args, &block); end

  def pos(*args, &block); end

  def pos=(*args, &block); end

  def pread(*args, &block); end

  def print(*args, &block); end

  def printf(*args, &block); end

  def putc(*args, &block); end

  def puts(*args, &block); end

  def pwrite(*args, &block); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def readbyte(*args, &block); end

  def readchar(*args, &block); end

  def readline(*args, &block); end

  def readlines(*args, &block); end

  def readpartial(*args, &block); end

  def ready?(*args, &block); end

  def reopen(*args, &block); end

  def respond_to?(name, priv=T.unsafe(nil)); end

  def rewind(*args, &block); end

  def seek(*args, &block); end

  def set_encoding(*args, &block); end

  def stat(*args, &block); end

  def sync(*args, &block); end

  def sync=(*args, &block); end

  def sysread(*args, &block); end

  def sysseek(*args, &block); end

  def syswrite(*args, &block); end

  def tell(*args, &block); end

  def to_i(*args, &block); end

  def to_io(*args, &block); end

  def tty?(*args, &block); end

  def ungetbyte(*args, &block); end

  def ungetc(*args, &block); end

  def wait(*args, &block); end

  def wait_readable(*args, &block); end

  def wait_writable(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
end

class RSpec::Core::OutputWrapper
end

class RSpec::Core::Parser
  def initialize(original_args); end

  def original_args(); end

  def parse(source=T.unsafe(nil)); end
end

class RSpec::Core::Parser
  def self.parse(args, source=T.unsafe(nil)); end
end

module RSpec::Core::Pending
  def pending(message=T.unsafe(nil)); end

  def skip(message=T.unsafe(nil)); end
  NOT_YET_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  NO_REASON_GIVEN = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Pending::PendingExampleFixedError
end

class RSpec::Core::Pending::PendingExampleFixedError
end

class RSpec::Core::Pending::SkipDeclaredInExample
  def argument(); end

  def initialize(argument); end
end

class RSpec::Core::Pending::SkipDeclaredInExample
end

module RSpec::Core::Pending
  def self.mark_fixed!(example); end

  def self.mark_pending!(example, message_or_bool); end

  def self.mark_skipped!(example, message_or_bool); end
end

class RSpec::Core::Profiler
  def example_group_finished(notification); end

  def example_group_started(notification); end

  def example_groups(); end

  def example_started(notification); end
  NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Profiler
end

class RSpec::Core::Reporter
  def abort_with(msg, exit_status); end

  def close_after(); end

  def deprecation(hash); end

  def example_failed(example); end

  def example_finished(example); end

  def example_group_finished(group); end

  def example_group_started(group); end

  def example_passed(example); end

  def example_pending(example); end

  def example_started(example); end

  def examples(); end

  def exit_early(exit_code); end

  def fail_fast_limit_met?(); end

  def failed_examples(); end

  def finish(); end

  def initialize(configuration); end

  def message(message); end

  def notify(event, notification); end

  def notify_non_example_exception(exception, context_description); end

  def pending_examples(); end

  def prepare_default(loader, output_stream, deprecation_stream); end

  def publish(event, options=T.unsafe(nil)); end

  def register_listener(listener, *notifications); end

  def registered_listeners(notification); end

  def report(expected_example_count); end

  def start(expected_example_count, time=T.unsafe(nil)); end

  def stop(); end
  RSPEC_NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Reporter
end

module RSpec::Core::RubyProject
end

module RSpec::Core::RubyProject
  def self.add_dir_to_load_path(dir); end

  def self.add_to_load_path(*dirs); end

  def self.ascend_until(); end

  def self.determine_root(); end

  def self.find_first_parent_containing(dir); end

  def self.root(); end
end

class RSpec::Core::Runner
  def configuration(); end

  def configure(err, out); end

  def initialize(options, configuration=T.unsafe(nil), world=T.unsafe(nil)); end

  def options(); end

  def run(err, out); end

  def run_specs(example_groups); end

  def setup(err, out); end

  def world(); end
end

class RSpec::Core::Runner
  def self.autorun(); end

  def self.autorun_disabled?(); end

  def self.disable_autorun!(); end

  def self.handle_interrupt(); end

  def self.installed_at_exit?(); end

  def self.invoke(); end

  def self.perform_at_exit(); end

  def self.run(args, err=T.unsafe(nil), out=T.unsafe(nil)); end

  def self.running_in_drb?(); end

  def self.trap_interrupt(); end
end

class RSpec::Core::Set
  include ::Enumerable
  def <<(key); end

  def clear(); end

  def delete(key); end

  def each(&block); end

  def empty?(); end

  def include?(key); end

  def initialize(array=T.unsafe(nil)); end

  def merge(values); end
end

class RSpec::Core::Set
end

module RSpec::Core::SharedContext
  def __shared_context_recordings(); end

  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def context(*args, &block); end

  def describe(*args, &block); end

  def hooks(*args, &block); end

  def included(group); end

  def let(*args, &block); end

  def let!(*args, &block); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end

  def subject(*args, &block); end

  def subject!(*args, &block); end
end

class RSpec::Core::SharedContext::Recording
  def args(); end

  def args=(_); end

  def block(); end

  def block=(_); end

  def method_name(); end

  def method_name=(_); end

  def playback_onto(group); end
end

class RSpec::Core::SharedContext::Recording
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::SharedContext
  def self.record(methods); end
end

module RSpec::Core::SharedExampleGroup
  def shared_context(name, *args, &block); end

  def shared_examples(name, *args, &block); end

  def shared_examples_for(name, *args, &block); end
end

class RSpec::Core::SharedExampleGroup::Registry
  def add(context, name, *metadata_args, &block); end

  def find(lookup_contexts, name); end
end

class RSpec::Core::SharedExampleGroup::Registry
end

module RSpec::Core::SharedExampleGroup::TopLevelDSL
end

module RSpec::Core::SharedExampleGroup::TopLevelDSL
  def self.definitions(); end

  def self.expose_globally!(); end

  def self.exposed_globally?(); end

  def self.remove_globally!(); end
end

module RSpec::Core::SharedExampleGroup
end

class RSpec::Core::SharedExampleGroupInclusionStackFrame
  def description(); end

  def formatted_inclusion_location(); end

  def inclusion_location(); end

  def initialize(shared_group_name, inclusion_location); end

  def shared_group_name(); end
end

class RSpec::Core::SharedExampleGroupInclusionStackFrame
  def self.current_backtrace(); end

  def self.shared_example_group_inclusions(); end

  def self.with_frame(name, location); end
end

class RSpec::Core::SharedExampleGroupModule
  def definition(); end

  def include_in(klass, inclusion_line, args, customization_block); end

  def included(klass); end

  def initialize(description, definition, metadata); end
end

class RSpec::Core::SharedExampleGroupModule
end

module RSpec::Core::ShellEscape
  SHELLS_ALLOWING_UNQUOTED_IDS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::ShellEscape
  def self.conditionally_quote(id); end

  def self.escape(shell_command); end

  def self.quote(argument); end

  def self.shell_allows_unquoted_ids?(); end
end

class RSpec::Core::SuiteHookContext
  def initialize(hook_description, reporter); end
end

class RSpec::Core::SuiteHookContext
end

class RSpec::Core::Time
end

class RSpec::Core::Time
  def self.now(); end
end

module RSpec::Core::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Version
end

module RSpec::Core::Warnings
  def deprecate(deprecated, data=T.unsafe(nil)); end

  def warn_deprecation(message, opts=T.unsafe(nil)); end

  def warn_with(message, options=T.unsafe(nil)); end
end

module RSpec::Core::Warnings
end

class RSpec::Core::World
  def all_example_groups(); end

  def all_examples(); end

  def announce_exclusion_filter(announcements); end

  def announce_filters(); end

  def announce_inclusion_filter(announcements); end

  def everything_filtered_message(); end

  def example_count(groups=T.unsafe(nil)); end

  def example_groups(); end

  def exclusion_filter(); end

  def filter_manager(); end

  def filtered_examples(); end

  def inclusion_filter(); end

  def initialize(configuration=T.unsafe(nil)); end

  def non_example_failure(); end

  def non_example_failure=(non_example_failure); end

  def num_example_groups_defined_in(file); end

  def ordered_example_groups(); end

  def preceding_declaration_line(absolute_file_name, filter_line); end

  def prepare_example_filtering(); end

  def record(example_group); end

  def registered_example_group_files(); end

  def report_filter_message(message); end

  def reporter(); end

  def reset(); end

  def shared_example_group_registry(); end

  def source_from_file(path); end

  def syntax_highlighter(); end

  def traverse_example_group_trees_until(&block); end

  def wants_to_quit(); end

  def wants_to_quit=(wants_to_quit); end
end

module RSpec::Core::World::Null
end

module RSpec::Core::World::Null
  def self.all_example_groups(); end

  def self.example_groups(); end

  def self.non_example_failure(); end

  def self.non_example_failure=(_); end

  def self.registered_example_group_files(); end

  def self.traverse_example_group_trees_until(); end
end

class RSpec::Core::World
end

module RSpec::Core
  def self.path_to_executable(); end
end

module RSpec::ExampleGroups
end

module RSpec::ExampleGroups
  extend ::RSpec::Support::RecursiveConstMethods
  def self.assign_const(group); end

  def self.base_name_for(group); end

  def self.constant_scope_for(group); end

  def self.disambiguate(name, const_scope); end

  def self.remove_all_constants(); end
end

module RSpec::Expectations
end

class RSpec::Expectations::BlockExpectationTarget
  def not_to(matcher, message=T.unsafe(nil), &block); end

  def to(matcher, message=T.unsafe(nil), &block); end

  def to_not(matcher, message=T.unsafe(nil), &block); end
end

class RSpec::Expectations::BlockExpectationTarget
end

class RSpec::Expectations::BlockSnippetExtractor
  def body_content_lines(); end

  def initialize(proc, method_name); end

  def method_name(); end
end

class RSpec::Expectations::BlockSnippetExtractor::AmbiguousTargetError
end

class RSpec::Expectations::BlockSnippetExtractor::AmbiguousTargetError
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_content_locations(); end

  def method_call_location(); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_tokens(); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end

  def state(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::Error
end

class RSpec::Expectations::BlockSnippetExtractor::Error
end

class RSpec::Expectations::BlockSnippetExtractor::TargetNotFoundError
end

class RSpec::Expectations::BlockSnippetExtractor::TargetNotFoundError
end

class RSpec::Expectations::BlockSnippetExtractor
  def self.try_extracting_single_line_body_of(proc, method_name); end
end

class RSpec::Expectations::Configuration
  def add_should_and_should_not_to(*modules); end

  def backtrace_formatter(); end

  def backtrace_formatter=(backtrace_formatter); end

  def color?(); end

  def false_positives_handler(); end

  def include_chain_clauses_in_custom_matcher_descriptions=(include_chain_clauses_in_custom_matcher_descriptions); end

  def include_chain_clauses_in_custom_matcher_descriptions?(); end

  def max_formatted_output_length=(length); end

  def on_potential_false_positives(); end

  def on_potential_false_positives=(behavior); end

  def reset_syntaxes_to_default(); end

  def syntax(); end

  def syntax=(values); end

  def warn_about_potential_false_positives=(boolean); end

  def warn_about_potential_false_positives?(); end
  FALSE_POSITIVE_BEHAVIOURS = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Configuration::NullBacktraceFormatter
end

module RSpec::Expectations::Configuration::NullBacktraceFormatter
  def self.format_backtrace(backtrace); end
end

class RSpec::Expectations::Configuration
end

module RSpec::Expectations::ExpectationHelper
end

module RSpec::Expectations::ExpectationHelper
  def self.check_message(msg); end

  def self.handle_failure(matcher, message, failure_message_method); end

  def self.modern_matcher_from(matcher); end

  def self.with_matcher(handler, matcher, message); end
end

class RSpec::Expectations::ExpectationNotMetError
end

class RSpec::Expectations::ExpectationNotMetError
end

class RSpec::Expectations::ExpectationTarget
  include ::RSpec::Expectations::ExpectationTarget::InstanceMethods
  def initialize(value); end

  def target(); end
end

module RSpec::Expectations::ExpectationTarget::InstanceMethods
  def not_to(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def to(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def to_not(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end
end

module RSpec::Expectations::ExpectationTarget::InstanceMethods
end

module RSpec::Expectations::ExpectationTarget::UndefinedValue
end

module RSpec::Expectations::ExpectationTarget::UndefinedValue
end

class RSpec::Expectations::ExpectationTarget
  def self.for(value, block); end
end

class RSpec::Expectations::FailureAggregator
  def aggregate(); end

  def block_label(); end

  def call(failure, options); end

  def failures(); end

  def initialize(block_label, metadata); end

  def metadata(); end

  def other_errors(); end
end

class RSpec::Expectations::FailureAggregator
end

RSpec::Expectations::LegacyMacherAdapter = RSpec::Expectations::LegacyMatcherAdapter

class RSpec::Expectations::LegacyMatcherAdapter
  def initialize(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec1
  def failure_message(); end

  def failure_message_when_negated(); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec1
  def self.interface_matches?(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec2
  def failure_message(); end

  def failure_message_when_negated(); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec2
  def self.interface_matches?(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter
  def self.wrap(matcher); end
end

class RSpec::Expectations::MultipleExpectationsNotMetError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
  def aggregation_block_label(); end

  def aggregation_metadata(); end

  def all_exceptions(); end

  def exception_count_description(); end

  def failures(); end

  def initialize(failure_aggregator); end

  def other_errors(); end

  def summary(); end
end

class RSpec::Expectations::MultipleExpectationsNotMetError
end

class RSpec::Expectations::NegativeExpectationHandler
end

class RSpec::Expectations::NegativeExpectationHandler
  def self.does_not_match?(matcher, actual, &block); end

  def self.handle_matcher(actual, initial_matcher, message=T.unsafe(nil), &block); end

  def self.opposite_should_method(); end

  def self.should_method(); end

  def self.verb(); end
end

class RSpec::Expectations::PositiveExpectationHandler
end

class RSpec::Expectations::PositiveExpectationHandler
  def self.handle_matcher(actual, initial_matcher, message=T.unsafe(nil), &block); end

  def self.opposite_should_method(); end

  def self.should_method(); end

  def self.verb(); end
end

module RSpec::Expectations::Syntax
end

module RSpec::Expectations::Syntax
  def self.default_should_host(); end

  def self.disable_expect(syntax_host=T.unsafe(nil)); end

  def self.disable_should(syntax_host=T.unsafe(nil)); end

  def self.enable_expect(syntax_host=T.unsafe(nil)); end

  def self.enable_should(syntax_host=T.unsafe(nil)); end

  def self.expect_enabled?(syntax_host=T.unsafe(nil)); end

  def self.should_enabled?(syntax_host=T.unsafe(nil)); end

  def self.warn_about_should!(); end

  def self.warn_about_should_unless_configured(method_name); end
end

module RSpec::Expectations::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Version
end

module RSpec::Expectations
  def self.configuration(); end

  def self.differ(); end

  def self.fail_with(message, expected=T.unsafe(nil), actual=T.unsafe(nil)); end
end

module RSpec::Matchers
  def a_block_changing(*args, &block); end

  def a_block_outputting(*args, &block); end

  def a_block_raising(*args, &block); end

  def a_block_throwing(*args, &block); end

  def a_block_yielding_control(*args, &block); end

  def a_block_yielding_successive_args(*args, &block); end

  def a_block_yielding_with_args(*args, &block); end

  def a_block_yielding_with_no_args(*args, &block); end

  def a_collection_containing_exactly(*args, &block); end

  def a_collection_ending_with(*args, &block); end

  def a_collection_including(*args, &block); end

  def a_collection_starting_with(*args, &block); end

  def a_falsey_value(*args, &block); end

  def a_falsy_value(*args, &block); end

  def a_hash_including(*args, &block); end

  def a_kind_of(*args, &block); end

  def a_nil_value(*args, &block); end

  def a_range_covering(*args, &block); end

  def a_string_ending_with(*args, &block); end

  def a_string_including(*args, &block); end

  def a_string_matching(*args, &block); end

  def a_string_starting_with(*args, &block); end

  def a_truthy_value(*args, &block); end

  def a_value(*args, &block); end

  def a_value_between(*args, &block); end

  def a_value_within(*args, &block); end

  def aggregate_failures(label=T.unsafe(nil), metadata=T.unsafe(nil), &block); end

  def all(expected); end

  def an_instance_of(*args, &block); end

  def an_object_eq_to(*args, &block); end

  def an_object_eql_to(*args, &block); end

  def an_object_equal_to(*args, &block); end

  def an_object_existing(*args, &block); end

  def an_object_having_attributes(*args, &block); end

  def an_object_matching(*args, &block); end

  def an_object_responding_to(*args, &block); end

  def an_object_satisfying(*args, &block); end

  def be(*args); end

  def be_a(klass); end

  def be_a_kind_of(expected); end

  def be_an(klass); end

  def be_an_instance_of(expected); end

  def be_between(min, max); end

  def be_falsey(); end

  def be_falsy(*args, &block); end

  def be_instance_of(expected); end

  def be_kind_of(expected); end

  def be_nil(); end

  def be_truthy(); end

  def be_within(delta); end

  def change(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def changing(*args, &block); end

  def contain_exactly(*items); end

  def containing_exactly(*args, &block); end

  def cover(*values); end

  def covering(*args, &block); end

  def end_with(*expected); end

  def ending_with(*args, &block); end

  def eq(expected); end

  def eq_to(*args, &block); end

  def eql(expected); end

  def eql_to(*args, &block); end

  def equal(expected); end

  def equal_to(*args, &block); end

  def exist(*args); end

  def existing(*args, &block); end

  def expect(value=T.unsafe(nil), &block); end

  def have_attributes(expected); end

  def having_attributes(*args, &block); end

  def include(*expected); end

  def including(*args, &block); end

  def match(expected); end

  def match_array(items); end

  def match_regex(*args, &block); end

  def matching(*args, &block); end

  def output(expected=T.unsafe(nil)); end

  def raise_error(error=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def raise_exception(error=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def raising(*args, &block); end

  def respond_to(*names); end

  def responding_to(*args, &block); end

  def satisfy(description=T.unsafe(nil), &block); end

  def satisfying(*args, &block); end

  def start_with(*expected); end

  def starting_with(*args, &block); end

  def throw_symbol(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def throwing(*args, &block); end

  def within(*args, &block); end

  def yield_control(); end

  def yield_successive_args(*args); end

  def yield_with_args(*args); end

  def yield_with_no_args(); end

  def yielding_control(*args, &block); end

  def yielding_successive_args(*args, &block); end

  def yielding_with_args(*args, &block); end

  def yielding_with_no_args(*args, &block); end
  BE_PREDICATE_REGEX = ::T.let(nil, ::T.untyped)
  DYNAMIC_MATCHER_REGEX = ::T.let(nil, ::T.untyped)
  HAS_REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::AliasedMatcher
  def description(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(base_matcher, description_block); end

  def method_missing(*_); end
end

class RSpec::Matchers::AliasedMatcher
end

class RSpec::Matchers::AliasedMatcherWithOperatorSupport
end

class RSpec::Matchers::AliasedMatcherWithOperatorSupport
end

class RSpec::Matchers::AliasedNegatedMatcher
  def does_not_match?(*args, &block); end

  def matches?(*args, &block); end
end

RSpec::Matchers::AliasedNegatedMatcher::DefaultFailureMessages = RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages

class RSpec::Matchers::AliasedNegatedMatcher
end

module RSpec::Matchers::BuiltIn
end

class RSpec::Matchers::BuiltIn::All
  def does_not_match?(_actual); end

  def failed_objects(); end

  def initialize(matcher); end

  def matcher(); end
end

class RSpec::Matchers::BuiltIn::All
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  include ::RSpec::Matchers::Composable
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def actual(); end

  def actual_formatted(); end

  def description(); end

  def diffable?(); end

  def expected(); end

  def expected_formatted(); end

  def expects_call_stack_jump?(); end

  def initialize(expected=T.unsafe(nil)); end

  def match_unless_raises(*exceptions); end

  def matcher_name(); end

  def matcher_name=(matcher_name); end

  def matches?(actual); end

  def present_ivars(); end

  def rescued_exception(); end

  def supports_block_expectations?(); end
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def failure_message(); end

  def failure_message_when_negated(); end
end

module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def self.has_default_failure_messages?(matcher); end
end

module RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
end

module RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
  def self.improve_hash_formatting(inspect_string); end
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  def self.matcher_name(); end
end

class RSpec::Matchers::BuiltIn::Be
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def <(operand); end

  def <=(operand); end

  def ==(operand); end

  def ===(operand); end

  def =~(operand); end

  def >(operand); end

  def >=(operand); end

  def initialize(*args); end
end

class RSpec::Matchers::BuiltIn::Be
end

class RSpec::Matchers::BuiltIn::BeAKindOf
end

class RSpec::Matchers::BuiltIn::BeAKindOf
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
end

class RSpec::Matchers::BuiltIn::BeBetween
  def exclusive(); end

  def inclusive(); end

  def initialize(min, max); end
end

class RSpec::Matchers::BuiltIn::BeBetween
end

class RSpec::Matchers::BuiltIn::BeComparedTo
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def initialize(operand, operator); end
end

class RSpec::Matchers::BuiltIn::BeComparedTo
end

class RSpec::Matchers::BuiltIn::BeFalsey
end

class RSpec::Matchers::BuiltIn::BeFalsey
end

module RSpec::Matchers::BuiltIn::BeHelpers
end

module RSpec::Matchers::BuiltIn::BeHelpers
end

class RSpec::Matchers::BuiltIn::BeNil
end

class RSpec::Matchers::BuiltIn::BeNil
end

class RSpec::Matchers::BuiltIn::BePredicate
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def does_not_match?(actual, &block); end

  def initialize(*args, &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::BePredicate
end

class RSpec::Matchers::BuiltIn::BeTruthy
end

class RSpec::Matchers::BuiltIn::BeTruthy
end

class RSpec::Matchers::BuiltIn::BeWithin
  def initialize(delta); end

  def of(expected); end

  def percent_of(expected); end
end

class RSpec::Matchers::BuiltIn::BeWithin
end

class RSpec::Matchers::BuiltIn::Change
  def by(expected_delta); end

  def by_at_least(minimum); end

  def by_at_most(maximum); end

  def does_not_match?(event_proc); end

  def from(value); end

  def initialize(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def matches?(event_proc); end

  def to(value); end
end

class RSpec::Matchers::BuiltIn::Change
end

class RSpec::Matchers::BuiltIn::Compound
  def diffable_matcher_list(); end

  def does_not_match?(_actual); end

  def evaluator(); end

  def initialize(matcher_1, matcher_2); end

  def matcher_1(); end

  def matcher_2(); end
end

class RSpec::Matchers::BuiltIn::Compound::And
end

class RSpec::Matchers::BuiltIn::Compound::And
end

class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  def initialize(actual, matcher_1, matcher_2); end

  def matcher_matches?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  def self.matcher_expects_call_stack_jump?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::Or
end

class RSpec::Matchers::BuiltIn::Compound::Or
end

class RSpec::Matchers::BuiltIn::Compound::SequentialEvaluator
  def initialize(actual, *_); end

  def matcher_matches?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::SequentialEvaluator
end

class RSpec::Matchers::BuiltIn::Compound
end

class RSpec::Matchers::BuiltIn::ContainExactly
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
  def actual_to_expected_matched_indexes(); end

  def expected_to_actual_matched_indexes(); end

  def find_best_solution(); end

  def initialize(expected_to_actual_matched_indexes, actual_to_expected_matched_indexes); end

  def solution(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
  def self.worse_than?(_other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def +(derived_candidate_solution); end

  def candidate?(); end

  def ideal?(); end

  def indeterminate_actual_indexes(); end

  def indeterminate_actual_indexes=(_); end

  def indeterminate_expected_indexes(); end

  def indeterminate_expected_indexes=(_); end

  def unmatched_actual_indexes(); end

  def unmatched_actual_indexes=(_); end

  def unmatched_expected_indexes(); end

  def unmatched_expected_indexes=(_); end

  def unmatched_item_count(); end

  def worse_than?(other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
end

class RSpec::Matchers::BuiltIn::ContainExactly
end

class RSpec::Matchers::BuiltIn::Cover
  def does_not_match?(range); end

  def initialize(*expected); end

  def matches?(range); end
end

class RSpec::Matchers::BuiltIn::Cover
end

class RSpec::Matchers::BuiltIn::EndWith
end

class RSpec::Matchers::BuiltIn::EndWith
end

class RSpec::Matchers::BuiltIn::Eq
end

class RSpec::Matchers::BuiltIn::Eq
end

class RSpec::Matchers::BuiltIn::Eql
end

class RSpec::Matchers::BuiltIn::Eql
end

class RSpec::Matchers::BuiltIn::Equal
  LITERAL_SINGLETONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Equal
end

class RSpec::Matchers::BuiltIn::Exist
  def does_not_match?(actual); end

  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
  def actual_exists?(); end

  def valid_test?(); end

  def validity_message(); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
end

class RSpec::Matchers::BuiltIn::Exist
end

class RSpec::Matchers::BuiltIn::Has
  def does_not_match?(actual, &block); end

  def initialize(method_name, *args, &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::Has
end

class RSpec::Matchers::BuiltIn::HaveAttributes
  def does_not_match?(actual); end

  def initialize(expected); end

  def respond_to_failed(); end
end

class RSpec::Matchers::BuiltIn::HaveAttributes
end

class RSpec::Matchers::BuiltIn::Include
  def does_not_match?(actual); end

  def expecteds(); end

  def initialize(*expecteds); end
end

class RSpec::Matchers::BuiltIn::Include
end

class RSpec::Matchers::BuiltIn::Match
  def initialize(expected); end

  def with_captures(*captures); end
end

class RSpec::Matchers::BuiltIn::Match
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def !=(_expected); end

  def !~(_expected); end

  def <(expected); end

  def <=(expected); end

  def ==(expected); end

  def ===(expected); end

  def =~(expected); end

  def >(expected); end

  def >=(expected); end

  def description(); end

  def fail_with_message(message); end

  def initialize(actual); end
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def self.get(klass, operator); end

  def self.register(klass, operator, matcher); end

  def self.registry(); end

  def self.unregister(klass, operator); end

  def self.use_custom_matcher_or_delegate(operator); end
end

class RSpec::Matchers::BuiltIn::Output
  def does_not_match?(block); end

  def initialize(expected); end

  def matches?(block); end

  def to_stderr(); end

  def to_stderr_from_any_process(); end

  def to_stdout(); end

  def to_stdout_from_any_process(); end
end

class RSpec::Matchers::BuiltIn::Output
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher
end

class RSpec::Matchers::BuiltIn::RaiseError
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_error_or_message=T.unsafe(nil), expected_message=T.unsafe(nil), &block); end

  def matches?(given_proc, negative_expectation=T.unsafe(nil), &block); end

  def supports_block_expectations?(); end

  def with_message(expected_message); end
end

class RSpec::Matchers::BuiltIn::RaiseError
end

class RSpec::Matchers::BuiltIn::RespondTo
  def and_any_keywords(); end

  def and_keywords(*keywords); end

  def and_unlimited_arguments(); end

  def argument(); end

  def arguments(); end

  def does_not_match?(actual); end

  def initialize(*names); end

  def with(n); end

  def with_any_keywords(); end

  def with_keywords(*keywords); end

  def with_unlimited_arguments(); end
end

class RSpec::Matchers::BuiltIn::RespondTo
end

class RSpec::Matchers::BuiltIn::Satisfy
  def initialize(description=T.unsafe(nil), &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::Satisfy
end

class RSpec::Matchers::BuiltIn::StartOrEndWith
  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::StartOrEndWith
end

class RSpec::Matchers::BuiltIn::StartWith
end

class RSpec::Matchers::BuiltIn::StartWith
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def matches?(given_proc); end

  def supports_block_expectations?(); end
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
end

class RSpec::Matchers::BuiltIn::YieldControl
  def at_least(number); end

  def at_most(number); end

  def does_not_match?(block); end

  def exactly(number); end

  def initialize(); end

  def matches?(block); end

  def once(); end

  def thrice(); end

  def times(); end

  def twice(); end
end

class RSpec::Matchers::BuiltIn::YieldControl
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
  def does_not_match?(block); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
end

module RSpec::Matchers::BuiltIn
end

module RSpec::Matchers::Composable
  def &(matcher); end

  def ===(value); end

  def and(matcher); end

  def or(matcher); end

  def |(matcher); end
end

module RSpec::Matchers::Composable
  def self.should_enumerate?(item); end

  def self.surface_descriptions_in(item); end

  def self.unreadable_io?(object); end
end

module RSpec::Matchers::DSL
  def alias_matcher(new_name, old_name, options=T.unsafe(nil), &description_override); end

  def define(name, &declarations); end

  def define_negated_matcher(negated_name, base_name, &description_override); end

  def matcher(name, &declarations); end
end

module RSpec::Matchers::DSL::DefaultImplementations
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def description(); end

  def diffable?(); end

  def expects_call_stack_jump?(); end

  def supports_block_expectations?(); end
end

module RSpec::Matchers::DSL::DefaultImplementations
end

module RSpec::Matchers::DSL::Macros
  def chain(method_name, *attr_names, &definition); end

  def description(&definition); end

  def diffable(); end

  def failure_message(&definition); end

  def failure_message_when_negated(&definition); end

  def match(options=T.unsafe(nil), &match_block); end

  def match_unless_raises(expected_exception=T.unsafe(nil), &match_block); end

  def match_when_negated(options=T.unsafe(nil), &match_block); end

  def supports_block_expectations(); end
  RAISE_NOTIFIER = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers::DSL::Macros::Deprecated
  def failure_message_for_should(&definition); end

  def failure_message_for_should_not(&definition); end

  def match_for_should(&definition); end

  def match_for_should_not(&definition); end
end

module RSpec::Matchers::DSL::Macros::Deprecated
end

module RSpec::Matchers::DSL::Macros
end

class RSpec::Matchers::DSL::Matcher
  include ::RSpec::Matchers::DSL::DefaultImplementations
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  include ::RSpec::Matchers
  include ::RSpec::Matchers::Composable
  def actual(); end

  def block_arg(); end

  def expected(); end

  def expected_as_array(); end

  def initialize(name, declarations, matcher_execution_context, *expected, &block_arg); end

  def name(); end

  def rescued_exception(); end
end

class RSpec::Matchers::DSL::Matcher
  extend ::RSpec::Matchers::DSL::Macros
  extend ::RSpec::Matchers::DSL::Macros::Deprecated
end

module RSpec::Matchers::DSL
end

module RSpec::Matchers::EnglishPhrasing
end

module RSpec::Matchers::EnglishPhrasing
  def self.list(obj); end

  def self.split_words(sym); end
end

class RSpec::Matchers::ExpectedsForMultipleDiffs
  def initialize(expected_list); end

  def message_with_diff(message, differ, actual); end
  DEFAULT_DIFF_LABEL = ::T.let(nil, ::T.untyped)
  DESCRIPTION_MAX_LENGTH = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::ExpectedsForMultipleDiffs
  def self.for_many_matchers(matchers); end

  def self.from(expected); end
end

class RSpec::Matchers::MatcherDelegator
  include ::RSpec::Matchers::Composable
  def base_matcher(); end

  def initialize(base_matcher); end

  def method_missing(*args, &block); end
end

class RSpec::Matchers::MatcherDelegator
end

module RSpec::Matchers
  extend ::RSpec::Matchers::DSL
  def self.alias_matcher(*args, &block); end

  def self.clear_generated_description(); end

  def self.configuration(); end

  def self.generated_description(); end

  def self.is_a_describable_matcher?(obj); end

  def self.is_a_matcher?(obj); end

  def self.last_description(); end

  def self.last_expectation_handler(); end

  def self.last_expectation_handler=(last_expectation_handler); end

  def self.last_matcher(); end

  def self.last_matcher=(last_matcher); end
end

module RSpec::Mocks
  DEFAULT_CALLBACK_INVOCATION_STRATEGY = ::T.let(nil, ::T.untyped)
  IGNORED_BACKTRACE_LINE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AllowanceTarget
  def expression(); end

  def not_to(matcher, *_args); end

  def to(matcher, &block); end

  def to_not(matcher, *_args); end
end

class RSpec::Mocks::AllowanceTarget
end

class RSpec::Mocks::AndReturnImplementation
  def call(*_args_to_ignore, &_block); end

  def initialize(values_to_return); end
end

class RSpec::Mocks::AndReturnImplementation
end

class RSpec::Mocks::AndWrapOriginalImplementation
  def call(*args, &block); end

  def initial_action=(_value); end

  def initialize(method, block); end

  def inner_action(); end

  def inner_action=(_value); end

  def present?(); end

  def terminal_action=(_value); end
end

class RSpec::Mocks::AndWrapOriginalImplementation::CannotModifyFurtherError
end

class RSpec::Mocks::AndWrapOriginalImplementation::CannotModifyFurtherError
end

class RSpec::Mocks::AndWrapOriginalImplementation
end

class RSpec::Mocks::AndYieldImplementation
  def call(*_args_to_ignore, &block); end

  def initialize(args_to_yield, eval_context, error_generator); end
end

class RSpec::Mocks::AndYieldImplementation
end

module RSpec::Mocks::AnyInstance
end

class RSpec::Mocks::AnyInstance::Chain
  include ::RSpec::Mocks::AnyInstance::Chain::Customizations
  def constrained_to_any_of?(*constraints); end

  def expectation_fulfilled!(); end

  def initialize(recorder, *args, &block); end

  def matches_args?(*args); end

  def never(); end

  def playback!(instance); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_wrap_original(*args, &block); end

  def and_yield(*args, &block); end

  def at_least(*args, &block); end

  def at_most(*args, &block); end

  def exactly(*args, &block); end

  def never(*args, &block); end

  def once(*args, &block); end

  def thrice(*args, &block); end

  def time(*args, &block); end

  def times(*args, &block); end

  def twice(*args, &block); end

  def with(*args, &block); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def self.record(method_name); end
end

class RSpec::Mocks::AnyInstance::Chain
end

class RSpec::Mocks::AnyInstance::ErrorGenerator
  def raise_does_not_implement_error(klass, method_name); end

  def raise_message_already_received_by_other_instance_error(method_name, object_inspect, invoked_instance); end

  def raise_not_supported_with_prepend_error(method_name, problem_mod); end

  def raise_second_instance_received_message_error(unfulfilled_expectations); end
end

class RSpec::Mocks::AnyInstance::ErrorGenerator
end

class RSpec::Mocks::AnyInstance::ExpectChainChain
  def initialize(*args); end
end

class RSpec::Mocks::AnyInstance::ExpectChainChain
end

class RSpec::Mocks::AnyInstance::ExpectationChain
  def expectation_fulfilled?(); end

  def initialize(*args, &block); end
end

class RSpec::Mocks::AnyInstance::ExpectationChain
end

class RSpec::Mocks::AnyInstance::FluentInterfaceProxy
  def initialize(targets); end

  def method_missing(*args, &block); end
end

class RSpec::Mocks::AnyInstance::FluentInterfaceProxy
end

class RSpec::Mocks::AnyInstance::MessageChains
  def [](method_name); end

  def add(method_name, chain); end

  def all_expectations_fulfilled?(); end

  def each_unfulfilled_expectation_matching(method_name, *args); end

  def has_expectation?(method_name); end

  def playback!(instance, method_name); end

  def received_expected_message!(method_name); end

  def remove_stub_chains_for!(method_name); end

  def unfulfilled_expectations(); end
end

class RSpec::Mocks::AnyInstance::MessageChains
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
  ExpectationInvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
end

class RSpec::Mocks::AnyInstance::Proxy
  def expect_chain(*chain, &block); end

  def initialize(recorder, target_proxies); end

  def klass(); end

  def should_not_receive(method_name, &block); end

  def should_receive(method_name, &block); end

  def stub(method_name_or_method_map, &block); end

  def stub_chain(*chain, &block); end

  def unstub(method_name); end
end

class RSpec::Mocks::AnyInstance::Proxy
end

class RSpec::Mocks::AnyInstance::Recorder
  def already_observing?(method_name); end

  def build_alias_method_name(method_name); end

  def expect_chain(*method_names_and_optional_return_values, &block); end

  def initialize(klass); end

  def instance_that_received(method_name); end

  def klass(); end

  def message_chains(); end

  def notify_received_message(_object, message, args, _blk); end

  def playback!(instance, method_name); end

  def should_not_receive(method_name, &block); end

  def should_receive(method_name, &block); end

  def stop_all_observation!(); end

  def stop_observing!(method_name); end

  def stub(method_name, &block); end

  def stub_chain(*method_names_and_optional_return_values, &block); end

  def stubs(); end

  def unstub(method_name); end

  def verify(); end
end

class RSpec::Mocks::AnyInstance::Recorder
end

class RSpec::Mocks::AnyInstance::StubChain
  def expectation_fulfilled?(); end
  EmptyInvocationOrder = ::T.let(nil, ::T.untyped)
  InvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::StubChain
end

class RSpec::Mocks::AnyInstance::StubChainChain
  def initialize(*args); end
end

class RSpec::Mocks::AnyInstance::StubChainChain
end

module RSpec::Mocks::AnyInstance
  def self.error_generator(); end
end

class RSpec::Mocks::AnyInstanceAllowanceTarget
  def expression(); end

  def not_to(matcher, *_args); end

  def to(matcher, &block); end

  def to_not(matcher, *_args); end
end

class RSpec::Mocks::AnyInstanceAllowanceTarget
end

class RSpec::Mocks::AnyInstanceExpectationTarget
  def expression(); end

  def not_to(matcher, &block); end

  def to(matcher, &block); end

  def to_not(matcher, &block); end
end

class RSpec::Mocks::AnyInstanceExpectationTarget
end

class RSpec::Mocks::ArgumentListMatcher
  def args_match?(*args); end

  def expected_args(); end

  def initialize(*expected_args); end

  def resolve_expected_args_based_on(actual_args); end
  MATCH_ALL = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentListMatcher
end

module RSpec::Mocks::ArgumentMatchers
  def a_kind_of(klass); end

  def an_instance_of(klass); end

  def any_args(); end

  def anything(); end

  def array_including(*args); end

  def boolean(); end

  def duck_type(*args); end

  def hash_excluding(*args); end

  def hash_including(*args); end

  def hash_not_including(*args); end

  def instance_of(klass); end

  def kind_of(klass); end

  def no_args(); end
end

module RSpec::Mocks::ArgumentMatchers
  def self.anythingize_lonely_keys(*args); end
end

class RSpec::Mocks::CallbackInvocationStrategy
  def call(doubled_module); end
end

class RSpec::Mocks::CallbackInvocationStrategy
end

class RSpec::Mocks::CannotSupportArgMutationsError
end

class RSpec::Mocks::CannotSupportArgMutationsError
end

class RSpec::Mocks::ClassNewMethodReference
end

class RSpec::Mocks::ClassNewMethodReference
  def self.applies_to?(method_name); end
end

class RSpec::Mocks::ClassVerifyingDouble
  include ::RSpec::Mocks::ObjectVerifyingDoubleMethods
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::ClassVerifyingDouble
end

class RSpec::Mocks::Configuration
  def add_stub_and_should_receive_to(*modules); end

  def allow_message_expectations_on_nil(); end

  def allow_message_expectations_on_nil=(allow_message_expectations_on_nil); end

  def before_verifying_doubles(&block); end

  def color?(); end

  def patch_marshal_to_support_partial_doubles=(val); end

  def reset_syntaxes_to_default(); end

  def syntax(); end

  def syntax=(*values); end

  def temporarily_suppress_partial_double_verification(); end

  def temporarily_suppress_partial_double_verification=(temporarily_suppress_partial_double_verification); end

  def transfer_nested_constants=(transfer_nested_constants); end

  def transfer_nested_constants?(); end

  def verify_doubled_constant_names=(verify_doubled_constant_names); end

  def verify_doubled_constant_names?(); end

  def verify_partial_doubles=(val); end

  def verify_partial_doubles?(); end

  def verifying_double_callbacks(); end

  def when_declaring_verifying_double(&block); end

  def yield_receiver_to_any_instance_implementation_blocks=(yield_receiver_to_any_instance_implementation_blocks); end

  def yield_receiver_to_any_instance_implementation_blocks?(); end
end

class RSpec::Mocks::Configuration
end

class RSpec::Mocks::Constant
  def hidden=(hidden); end

  def hidden?(); end

  def initialize(name); end

  def mutated?(); end

  def name(); end

  def original_value(); end

  def original_value=(original_value); end

  def previously_defined=(previously_defined); end

  def previously_defined?(); end

  def stubbed=(stubbed); end

  def stubbed?(); end

  def valid_name=(valid_name); end

  def valid_name?(); end
end

class RSpec::Mocks::Constant
  extend ::RSpec::Support::RecursiveConstMethods
  def self.original(name); end

  def self.unmutated(name); end
end

class RSpec::Mocks::ConstantMutator
end

class RSpec::Mocks::ConstantMutator::BaseMutator
  include ::RSpec::Support::RecursiveConstMethods
  def full_constant_name(); end

  def idempotently_reset(); end

  def initialize(full_constant_name, mutated_value, transfer_nested_constants); end

  def original_value(); end

  def to_constant(); end
end

class RSpec::Mocks::ConstantMutator::BaseMutator
end

class RSpec::Mocks::ConstantMutator::ConstantHider
  def mutate(); end

  def reset(); end
end

class RSpec::Mocks::ConstantMutator::ConstantHider
end

class RSpec::Mocks::ConstantMutator::DefinedConstantReplacer
  def initialize(*args); end

  def mutate(); end

  def reset(); end

  def should_transfer_nested_constants?(); end

  def transfer_nested_constants(); end

  def verify_constants_to_transfer!(); end
end

class RSpec::Mocks::ConstantMutator::DefinedConstantReplacer
end

class RSpec::Mocks::ConstantMutator::UndefinedConstantSetter
  def mutate(); end

  def reset(); end
end

class RSpec::Mocks::ConstantMutator::UndefinedConstantSetter
end

class RSpec::Mocks::ConstantMutator
  extend ::RSpec::Support::RecursiveConstMethods
  def self.hide(constant_name); end

  def self.mutate(mutator); end

  def self.raise_on_invalid_const(); end

  def self.stub(constant_name, value, options=T.unsafe(nil)); end
end

class RSpec::Mocks::DirectObjectReference
  def const_to_replace(); end

  def defined?(); end

  def description(); end

  def initialize(object); end

  def target(); end

  def when_loaded(); end
end

class RSpec::Mocks::DirectObjectReference
end

class RSpec::Mocks::Double
  include ::RSpec::Mocks::TestDouble
end

class RSpec::Mocks::Double
end

class RSpec::Mocks::ErrorGenerator
  def default_error_message(expectation, expected_args, actual_args); end

  def describe_expectation(verb, message, expected_received_count, _actual_received_count, args); end

  def expectation_on_nil_message(method_name); end

  def initialize(target=T.unsafe(nil)); end

  def intro(unwrapped=T.unsafe(nil)); end

  def method_call_args_description(args, generic_prefix=T.unsafe(nil), matcher_prefix=T.unsafe(nil)); end

  def opts(); end

  def opts=(opts); end

  def raise_already_invoked_error(message, calling_customization); end

  def raise_cant_constrain_count_for_negated_have_received_error(count_constraint); end

  def raise_double_negation_error(wrapped_expression); end

  def raise_expectation_error(message, expected_received_count, argument_list_matcher, actual_received_count, expectation_count_type, args, backtrace_line=T.unsafe(nil), source_id=T.unsafe(nil)); end

  def raise_expectation_on_mocked_method(method); end

  def raise_expectation_on_nil_error(method_name); end

  def raise_expectation_on_unstubbed_method(method); end

  def raise_expired_test_double_error(); end

  def raise_have_received_disallowed(type, reason); end

  def raise_invalid_arguments_error(verifier); end

  def raise_method_not_stubbed_error(method_name); end

  def raise_missing_block_error(args_to_yield); end

  def raise_missing_default_stub_error(expectation, args_for_multiple_calls); end

  def raise_non_public_error(method_name, visibility); end

  def raise_only_valid_on_a_partial_double(method); end

  def raise_out_of_order_error(message); end

  def raise_similar_message_args_error(expectation, args_for_multiple_calls, backtrace_line=T.unsafe(nil)); end

  def raise_unexpected_message_args_error(expectation, args_for_multiple_calls, source_id=T.unsafe(nil)); end

  def raise_unexpected_message_error(message, args); end

  def raise_unimplemented_error(doubled_module, method_name, object); end

  def raise_verifying_double_not_defined_error(ref); end

  def raise_wrong_arity_error(args_to_yield, signature); end
end

class RSpec::Mocks::ErrorGenerator
end

module RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  def allow(target); end

  def allow_any_instance_of(klass); end

  def allow_message_expectations_on_nil(); end

  def class_double(doubled_class, *args); end

  def class_spy(*args); end

  def double(*args); end

  def expect_any_instance_of(klass); end

  def have_received(method_name, &block); end

  def hide_const(constant_name); end

  def instance_double(doubled_class, *args); end

  def instance_spy(*args); end

  def object_double(object_or_name, *args); end

  def object_spy(*args); end

  def receive(method_name, &block); end

  def receive_message_chain(*messages, &block); end

  def receive_messages(message_return_value_hash); end

  def spy(*args); end

  def stub_const(constant_name, value, options=T.unsafe(nil)); end

  def without_partial_double_verification(); end
end

module RSpec::Mocks::ExampleMethods::ExpectHost
  def expect(target); end
end

module RSpec::Mocks::ExampleMethods::ExpectHost
end

module RSpec::Mocks::ExampleMethods
  def self.declare_double(type, *args); end

  def self.declare_verifying_double(type, ref, *args); end

  def self.extended(object); end

  def self.included(klass); end
end

class RSpec::Mocks::ExpectChain
end

class RSpec::Mocks::ExpectChain
  def self.expect_chain_on(object, *chain, &blk); end
end

class RSpec::Mocks::ExpectationTarget
  include ::RSpec::Mocks::ExpectationTargetMethods
end

class RSpec::Mocks::ExpectationTarget
end

module RSpec::Mocks::ExpectationTargetMethods
  include ::RSpec::Mocks::TargetDelegationInstanceMethods
  def expression(); end

  def not_to(matcher, &block); end

  def to(matcher, &block); end

  def to_not(matcher, &block); end
end

module RSpec::Mocks::ExpectationTargetMethods
  extend ::RSpec::Mocks::TargetDelegationClassMethods
end

class RSpec::Mocks::ExpiredTestDoubleError
end

class RSpec::Mocks::ExpiredTestDoubleError
end

class RSpec::Mocks::Implementation
  def call(*args, &block); end

  def initial_action(); end

  def initial_action=(initial_action); end

  def inner_action(); end

  def inner_action=(inner_action); end

  def present?(); end

  def terminal_action(); end

  def terminal_action=(terminal_action); end
end

class RSpec::Mocks::Implementation
end

class RSpec::Mocks::InstanceMethodReference
end

class RSpec::Mocks::InstanceMethodReference
end

class RSpec::Mocks::InstanceMethodStasher
  def handle_restoration_failures(); end

  def initialize(object, method); end

  def method_is_stashed?(); end

  def original_method(); end

  def restore(); end

  def stash(); end
end

class RSpec::Mocks::InstanceMethodStasher
end

class RSpec::Mocks::InstanceVerifyingDouble
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::InstanceVerifyingDouble
end

class RSpec::Mocks::MarshalExtension
end

class RSpec::Mocks::MarshalExtension
  def self.patch!(); end

  def self.unpatch!(); end
end

module RSpec::Mocks::Matchers
end

class RSpec::Mocks::Matchers::HaveReceived
  include ::RSpec::Mocks::Matchers::Matcher
  def at_least(*args); end

  def at_most(*args); end

  def description(); end

  def does_not_match?(subject); end

  def exactly(*args); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(method_name, &block); end

  def matches?(subject, &block); end

  def name(); end

  def once(*args); end

  def ordered(*args); end

  def setup_allowance(_subject, &_block); end

  def setup_any_instance_allowance(_subject, &_block); end

  def setup_any_instance_expectation(_subject, &_block); end

  def setup_any_instance_negative_expectation(_subject, &_block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(subject, &block); end

  def thrice(*args); end

  def time(*args); end

  def times(*args); end

  def twice(*args); end

  def with(*args); end
  ARGS_CONSTRAINTS = ::T.let(nil, ::T.untyped)
  CONSTRAINTS = ::T.let(nil, ::T.untyped)
  COUNT_CONSTRAINTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Matchers::HaveReceived
end

module RSpec::Mocks::Matchers::Matcher
end

module RSpec::Mocks::Matchers::Matcher
end

class RSpec::Mocks::Matchers::Receive
  include ::RSpec::Mocks::Matchers::Matcher
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_wrap_original(*args, &block); end

  def and_yield(*args, &block); end

  def at_least(*args, &block); end

  def at_most(*args, &block); end

  def description(); end

  def does_not_match?(subject, &block); end

  def exactly(*args, &block); end

  def initialize(message, block); end

  def matches?(subject, &block); end

  def name(); end

  def never(*args, &block); end

  def once(*args, &block); end

  def ordered(*args, &block); end

  def setup_allowance(subject, &block); end

  def setup_any_instance_allowance(subject, &block); end

  def setup_any_instance_expectation(subject, &block); end

  def setup_any_instance_negative_expectation(subject, &block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(subject, &block); end

  def thrice(*args, &block); end

  def time(*args, &block); end

  def times(*args, &block); end

  def twice(*args, &block); end

  def with(*args, &block); end
end

class RSpec::Mocks::Matchers::Receive::DefaultDescribable
  def description_for(verb); end

  def initialize(message); end
end

class RSpec::Mocks::Matchers::Receive::DefaultDescribable
end

class RSpec::Mocks::Matchers::Receive
end

class RSpec::Mocks::Matchers::ReceiveMessageChain
  include ::RSpec::Mocks::Matchers::Matcher
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_yield(*args, &block); end

  def description(); end

  def does_not_match?(*_args); end

  def initialize(chain, &block); end

  def matches?(subject, &block); end

  def name(); end

  def setup_allowance(subject, &block); end

  def setup_any_instance_allowance(subject, &block); end

  def setup_any_instance_expectation(subject, &block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(*_args); end

  def with(*args, &block); end
end

class RSpec::Mocks::Matchers::ReceiveMessageChain
end

class RSpec::Mocks::Matchers::ReceiveMessages
  include ::RSpec::Mocks::Matchers::Matcher
  def description(); end

  def does_not_match?(_subject); end

  def initialize(message_return_value_hash); end

  def matches?(subject); end

  def name(); end

  def setup_allowance(subject); end

  def setup_any_instance_allowance(subject); end

  def setup_any_instance_expectation(subject); end

  def setup_expectation(subject); end

  def setup_negative_expectation(_subject); end

  def warn_about_block(); end
end

class RSpec::Mocks::Matchers::ReceiveMessages
end

module RSpec::Mocks::Matchers
end

class RSpec::Mocks::MessageChain
  def block(); end

  def chain(); end

  def initialize(object, *chain, &blk); end

  def object(); end

  def setup_chain(); end
end

class RSpec::Mocks::MessageChain
end

class RSpec::Mocks::MessageExpectation
  include ::RSpec::Mocks::MessageExpectation::ImplementationDetails
  def and_call_original(); end

  def and_raise(*args); end

  def and_return(first_value, *values); end

  def and_throw(*args); end

  def and_wrap_original(&block); end

  def and_yield(*args, &block); end

  def at_least(n, &block); end

  def at_most(n, &block); end

  def exactly(n, &block); end

  def never(); end

  def once(&block); end

  def ordered(&block); end

  def thrice(&block); end

  def time(&block); end

  def times(&block); end

  def twice(&block); end

  def with(*args, &block); end
end

module RSpec::Mocks::MessageExpectation::ImplementationDetails
  def actual_received_count_matters?(); end

  def additional_expected_calls(); end

  def advise(*args); end

  def and_yield_receiver_to_implementation(); end

  def argument_list_matcher=(argument_list_matcher); end

  def called_max_times?(); end

  def description_for(verb); end

  def ensure_expected_ordering_received!(); end

  def error_generator(); end

  def error_generator=(error_generator); end

  def expectation_count_type(); end

  def expected_args(); end

  def expected_from=(expected_from); end

  def expected_messages_received?(); end

  def expected_received_count=(expected_received_count); end

  def generate_error(); end

  def ignoring_args?(); end

  def implementation(); end

  def implementation=(implementation); end

  def increase_actual_received_count!(); end

  def initialize(error_generator, expectation_ordering, expected_from, method_double, type=T.unsafe(nil), opts=T.unsafe(nil), &implementation_block); end

  def invoke(parent_stub, *args, &block); end

  def invoke_without_incrementing_received_count(parent_stub, *args, &block); end

  def matches?(message, *args); end

  def matches_at_least_count?(); end

  def matches_at_most_count?(); end

  def matches_exact_count?(); end

  def matches_name_but_not_args(message, *args); end

  def message(); end

  def negative?(); end

  def negative_expectation_for?(message); end

  def ordered?(); end

  def orig_object(); end

  def raise_out_of_order_error(); end

  def raise_unexpected_message_args_error(args_for_multiple_calls); end

  def safe_invoke(parent_stub, *args, &block); end

  def similar_messages(); end

  def type(); end

  def unadvise(args); end

  def verify_messages_received(); end

  def yield_receiver_to_implementation_block?(); end
end

module RSpec::Mocks::MessageExpectation::ImplementationDetails
end

class RSpec::Mocks::MessageExpectation
end

class RSpec::Mocks::MethodDouble
  def add_default_stub(*args, &implementation); end

  def add_expectation(error_generator, expectation_ordering, expected_from, opts, &implementation); end

  def add_simple_expectation(method_name, response, error_generator, backtrace_line); end

  def add_simple_stub(method_name, response); end

  def add_stub(error_generator, expectation_ordering, expected_from, opts=T.unsafe(nil), &implementation); end

  def build_expectation(error_generator, expectation_ordering); end

  def clear(); end

  def configure_method(); end

  def define_proxy_method(); end

  def expectations(); end

  def initialize(object, method_name, proxy); end

  def message_expectation_class(); end

  def method_name(); end

  def method_stasher(); end

  def object(); end

  def object_singleton_class(); end

  def original_implementation_callable(); end

  def original_method(); end

  def proxy_method_invoked(_obj, *args, &block); end

  def raise_method_not_stubbed_error(); end

  def remove_stub(); end

  def remove_stub_if_present(); end

  def reset(); end

  def restore_original_method(); end

  def restore_original_visibility(); end

  def save_original_implementation_callable!(); end

  def setup_simple_method_double(method_name, response, collection, error_generator=T.unsafe(nil), backtrace_line=T.unsafe(nil)); end

  def show_frozen_warning(); end

  def stubs(); end

  def verify(); end

  def visibility(); end
end

class RSpec::Mocks::MethodDouble::RSpecPrependedModule
end

class RSpec::Mocks::MethodDouble::RSpecPrependedModule
end

class RSpec::Mocks::MethodDouble
end

class RSpec::Mocks::MethodReference
  def defined?(); end

  def implemented?(); end

  def initialize(object_reference, method_name); end

  def unimplemented?(); end

  def visibility(); end

  def with_signature(); end
end

class RSpec::Mocks::MethodReference
  def self.for(object_reference, method_name); end

  def self.instance_method_visibility_for(klass, method_name); end

  def self.method_defined_at_any_visibility?(klass, method_name); end

  def self.method_visibility_for(object, method_name); end
end

class RSpec::Mocks::MockExpectationAlreadyInvokedError
end

class RSpec::Mocks::MockExpectationAlreadyInvokedError
end

class RSpec::Mocks::MockExpectationError
end

class RSpec::Mocks::MockExpectationError
end

class RSpec::Mocks::NamedObjectReference
  def const_to_replace(); end

  def defined?(); end

  def description(); end

  def initialize(const_name); end

  def target(); end

  def when_loaded(); end
end

class RSpec::Mocks::NamedObjectReference
end

class RSpec::Mocks::NegationUnsupportedError
end

class RSpec::Mocks::NegationUnsupportedError
end

class RSpec::Mocks::NestedSpace
  def initialize(parent); end
end

class RSpec::Mocks::NestedSpace
end

class RSpec::Mocks::NoCallbackInvocationStrategy
  def call(_doubled_module); end
end

class RSpec::Mocks::NoCallbackInvocationStrategy
end

class RSpec::Mocks::ObjectMethodReference
end

class RSpec::Mocks::ObjectMethodReference
end

class RSpec::Mocks::ObjectReference
  MODULE_NAME_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ObjectReference
  def self.for(object_module_or_name, allow_direct_object_refs=T.unsafe(nil)); end
end

class RSpec::Mocks::ObjectVerifyingDouble
  include ::RSpec::Mocks::ObjectVerifyingDoubleMethods
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::ObjectVerifyingDouble
end

module RSpec::Mocks::ObjectVerifyingDoubleMethods
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
  def as_stubbed_const(options=T.unsafe(nil)); end
end

module RSpec::Mocks::ObjectVerifyingDoubleMethods
end

class RSpec::Mocks::OrderGroup
  def clear(); end

  def consume(); end

  def empty?(); end

  def handle_order_constraint(expectation); end

  def invoked(message); end

  def ready_for?(expectation); end

  def register(expectation); end

  def verify_invocation_order(expectation); end
end

class RSpec::Mocks::OrderGroup
end

class RSpec::Mocks::OutsideOfExampleError
end

class RSpec::Mocks::OutsideOfExampleError
end

class RSpec::Mocks::PartialClassDoubleProxy
  include ::RSpec::Mocks::PartialClassDoubleProxyMethods
end

class RSpec::Mocks::PartialClassDoubleProxy
end

module RSpec::Mocks::PartialClassDoubleProxyMethods
  def initialize(source_space, *args); end

  def method_double_from_ancestor_for(message); end

  def original_method_handle_for(message); end

  def original_unbound_method_handle_from_ancestor_for(message); end

  def superclass_proxy(); end
end

module RSpec::Mocks::PartialClassDoubleProxyMethods
end

class RSpec::Mocks::PartialDoubleProxy
  def original_method_handle_for(message); end

  def visibility_for(method_name); end
end

class RSpec::Mocks::PartialDoubleProxy
end

class RSpec::Mocks::Proxy
  def add_message_expectation(method_name, opts=T.unsafe(nil), &block); end

  def add_simple_expectation(method_name, response, location); end

  def add_simple_stub(method_name, response); end

  def add_stub(method_name, opts=T.unsafe(nil), &implementation); end

  def build_expectation(method_name); end

  def check_for_unexpected_arguments(expectation); end

  def ensure_implemented(*_args); end

  def has_negative_expectation?(message); end

  def initialize(object, order_group, options=T.unsafe(nil)); end

  def message_received(message, *args, &block); end

  def messages_arg_list(); end

  def method_double_if_exists_for_message(message); end

  def object(); end

  def original_method_handle_for(_message); end

  def prepended_modules_of_singleton_class(); end

  def raise_missing_default_stub_error(expectation, args_for_multiple_calls); end

  def raise_unexpected_message_error(method_name, args); end

  def received_message?(method_name, *args, &block); end

  def record_message_received(message, *args, &block); end

  def remove_stub(method_name); end

  def remove_stub_if_present(method_name); end

  def replay_received_message_on(expectation, &block); end

  def reset(); end

  def verify(); end

  def visibility_for(_method_name); end
  DEFAULT_MESSAGE_EXPECTATION_OPTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Proxy::SpecificMessage
  def ==(expectation); end

  def args(); end

  def args=(_); end

  def message(); end

  def message=(_); end

  def object(); end

  def object=(_); end
end

class RSpec::Mocks::Proxy::SpecificMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Mocks::Proxy
  def self.prepended_modules_of(klass); end
end

class RSpec::Mocks::ProxyForNil
  def disallow_expectations(); end

  def disallow_expectations=(disallow_expectations); end

  def initialize(order_group); end

  def warn_about_expectations(); end

  def warn_about_expectations=(warn_about_expectations); end
end

class RSpec::Mocks::ProxyForNil
end

class RSpec::Mocks::RootSpace
  def any_instance_proxy_for(*_args); end

  def any_instance_recorder_for(*_args); end

  def any_instance_recorders_from_ancestry_of(_object); end

  def new_scope(); end

  def proxy_for(*_args); end

  def register_constant_mutator(_mutator); end

  def registered?(_object); end

  def reset_all(); end

  def superclass_proxy_for(*_args); end

  def verify_all(); end
end

class RSpec::Mocks::RootSpace
end

class RSpec::Mocks::SimpleMessageExpectation
  def called_max_times?(); end

  def initialize(message, response, error_generator, backtrace_line=T.unsafe(nil)); end

  def invoke(*_); end

  def matches?(message, *_); end

  def unadvise(_); end

  def verify_messages_received(); end
end

class RSpec::Mocks::SimpleMessageExpectation
end

class RSpec::Mocks::Space
  def any_instance_mutex(); end

  def any_instance_proxy_for(klass); end

  def any_instance_recorder_for(klass, only_return_existing=T.unsafe(nil)); end

  def any_instance_recorders(); end

  def any_instance_recorders_from_ancestry_of(object); end

  def constant_mutator_for(name); end

  def ensure_registered(object); end

  def new_scope(); end

  def proxies(); end

  def proxies_of(klass); end

  def proxy_for(object); end

  def proxy_mutex(); end

  def register_constant_mutator(mutator); end

  def registered?(object); end

  def reset_all(); end

  def superclass_proxy_for(klass); end

  def verify_all(); end
end

class RSpec::Mocks::Space
end

class RSpec::Mocks::StubChain
end

class RSpec::Mocks::StubChain
  def self.stub_chain_on(object, *chain, &blk); end
end

module RSpec::Mocks::Syntax
end

module RSpec::Mocks::Syntax
  def self.default_should_syntax_host(); end

  def self.disable_expect(syntax_host=T.unsafe(nil)); end

  def self.disable_should(syntax_host=T.unsafe(nil)); end

  def self.enable_expect(syntax_host=T.unsafe(nil)); end

  def self.enable_should(syntax_host=T.unsafe(nil)); end

  def self.expect_enabled?(syntax_host=T.unsafe(nil)); end

  def self.should_enabled?(syntax_host=T.unsafe(nil)); end

  def self.warn_about_should!(); end

  def self.warn_unless_should_configured(method_name, replacement=T.unsafe(nil)); end
end

class RSpec::Mocks::TargetBase
  include ::RSpec::Mocks::TargetDelegationInstanceMethods
  def initialize(target); end
end

class RSpec::Mocks::TargetBase
  extend ::RSpec::Mocks::TargetDelegationClassMethods
end

module RSpec::Mocks::TargetDelegationClassMethods
  def delegate_not_to(matcher_method, options=T.unsafe(nil)); end

  def delegate_to(matcher_method); end

  def disallow_negation(method_name); end
end

module RSpec::Mocks::TargetDelegationClassMethods
end

module RSpec::Mocks::TargetDelegationInstanceMethods
  def target(); end
end

module RSpec::Mocks::TargetDelegationInstanceMethods
end

module RSpec::Mocks::TestDouble
  def ==(other); end

  def __build_mock_proxy_unless_expired(order_group); end

  def __disallow_further_usage!(); end

  def as_null_object(); end

  def freeze(); end

  def initialize(name=T.unsafe(nil), stubs=T.unsafe(nil)); end

  def inspect(); end

  def null_object?(); end

  def respond_to?(message, incl_private=T.unsafe(nil)); end

  def to_s(); end
end

module RSpec::Mocks::TestDouble
end

module RSpec::Mocks::TestDoubleFormatter
end

module RSpec::Mocks::TestDoubleFormatter
  def self.format(dbl, unwrap=T.unsafe(nil)); end
end

class RSpec::Mocks::TestDoubleProxy
end

class RSpec::Mocks::TestDoubleProxy
end

class RSpec::Mocks::UnsupportedMatcherError
end

class RSpec::Mocks::UnsupportedMatcherError
end

module RSpec::Mocks::VerifyingDouble
  def __send__(name, *args, &block); end

  def initialize(doubled_module, *args); end

  def method_missing(message, *args, &block); end

  def respond_to?(message, include_private=T.unsafe(nil)); end

  def send(name, *args, &block); end
end

module RSpec::Mocks::VerifyingDouble::SilentIO
end

module RSpec::Mocks::VerifyingDouble::SilentIO
end

module RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::VerifyingDoubleNotDefinedError
end

class RSpec::Mocks::VerifyingDoubleNotDefinedError
end

class RSpec::Mocks::VerifyingExistingClassNewMethodDouble
end

class RSpec::Mocks::VerifyingExistingClassNewMethodDouble
end

class RSpec::Mocks::VerifyingExistingMethodDouble
  def initialize(object, method_name, proxy); end

  def unimplemented?(); end

  def with_signature(); end
end

class RSpec::Mocks::VerifyingExistingMethodDouble
  def self.for(object, method_name, proxy); end
end

class RSpec::Mocks::VerifyingMessageExpectation
  def initialize(*args); end

  def method_reference(); end

  def method_reference=(method_reference); end
end

class RSpec::Mocks::VerifyingMessageExpectation
end

class RSpec::Mocks::VerifyingMethodDouble
  def add_expectation(*args, &block); end

  def add_stub(*args, &block); end

  def initialize(object, method_name, proxy, method_reference); end

  def proxy_method_invoked(obj, *args, &block); end

  def validate_arguments!(actual_args); end
end

class RSpec::Mocks::VerifyingMethodDouble
end

class RSpec::Mocks::VerifyingPartialClassDoubleProxy
  include ::RSpec::Mocks::PartialClassDoubleProxyMethods
end

class RSpec::Mocks::VerifyingPartialClassDoubleProxy
end

class RSpec::Mocks::VerifyingPartialDoubleProxy
  include ::RSpec::Mocks::VerifyingProxyMethods
  def ensure_implemented(_method_name); end

  def initialize(object, expectation_ordering, optional_callback_invocation_strategy=T.unsafe(nil)); end

  def method_reference(); end
end

class RSpec::Mocks::VerifyingPartialDoubleProxy
end

class RSpec::Mocks::VerifyingProxy
  include ::RSpec::Mocks::VerifyingProxyMethods
  def initialize(object, order_group, doubled_module, method_reference_class); end

  def method_reference(); end

  def validate_arguments!(method_name, args); end

  def visibility_for(method_name); end
end

class RSpec::Mocks::VerifyingProxy
end

module RSpec::Mocks::VerifyingProxyMethods
  def add_message_expectation(method_name, opts=T.unsafe(nil), &block); end

  def add_simple_stub(method_name, *args); end

  def add_stub(method_name, opts=T.unsafe(nil), &implementation); end

  def ensure_implemented(method_name); end

  def ensure_publicly_implemented(method_name, _object); end
end

module RSpec::Mocks::VerifyingProxyMethods
end

module RSpec::Mocks::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks::Version
end

module RSpec::Mocks
  def self.allow_message(subject, message, opts=T.unsafe(nil), &block); end

  def self.configuration(); end

  def self.error_generator(); end

  def self.expect_message(subject, message, opts=T.unsafe(nil), &block); end

  def self.setup(); end

  def self.space(); end

  def self.teardown(); end

  def self.verify(); end

  def self.with_temporary_scope(); end
end

RSpec::SharedContext = RSpec::Core::SharedContext

module RSpec::Support
  DEFAULT_FAILURE_NOTIFIER = ::T.let(nil, ::T.untyped)
  DEFAULT_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  KERNEL_METHOD_METHOD = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  AVOID_RESCUING = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  def self.===(exception); end
end

class RSpec::Support::BlockSignature
end

class RSpec::Support::BlockSignature
end

class RSpec::Support::ComparableVersion
  include ::Comparable
  def initialize(string); end

  def segments(); end

  def string(); end
end

class RSpec::Support::ComparableVersion
end

class RSpec::Support::Differ
  def color?(); end

  def diff(actual, expected); end

  def diff_as_object(actual, expected); end

  def diff_as_string(actual, expected); end

  def initialize(opts=T.unsafe(nil)); end
end

class RSpec::Support::Differ
end

class RSpec::Support::DirectoryMaker
end

class RSpec::Support::DirectoryMaker
  def self.mkdir_p(path); end
end

class RSpec::Support::EncodedString
  def <<(string); end

  def ==(*args, &block); end

  def empty?(*args, &block); end

  def encoding(*args, &block); end

  def eql?(*args, &block); end

  def initialize(string, encoding=T.unsafe(nil)); end

  def lines(*args, &block); end

  def source_encoding(); end

  def split(regex_or_string); end

  def to_str(); end
  REPLACE = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::EncodedString
  def self.pick_encoding(source_a, source_b); end
end

module RSpec::Support::FuzzyMatcher
end

module RSpec::Support::FuzzyMatcher
  def self.values_match?(expected, actual); end
end

class RSpec::Support::LooseSignatureVerifier
end

class RSpec::Support::LooseSignatureVerifier::SignatureWithKeywordArgumentsMatcher
  def has_kw_args_in?(args); end

  def initialize(signature); end

  def invalid_kw_args_from(_kw_args); end

  def missing_kw_args_from(_kw_args); end

  def non_kw_args_arity_description(); end

  def valid_non_kw_args?(*args); end
end

class RSpec::Support::LooseSignatureVerifier::SignatureWithKeywordArgumentsMatcher
end

class RSpec::Support::LooseSignatureVerifier
end

class RSpec::Support::MethodSignature
  def arbitrary_kw_args?(); end

  def classify_arity(arity=T.unsafe(nil)); end

  def classify_parameters(); end

  def could_contain_kw_args?(args); end

  def description(); end

  def has_kw_args_in?(args); end

  def initialize(method); end

  def invalid_kw_args_from(given_kw_args); end

  def max_non_kw_args(); end

  def min_non_kw_args(); end

  def missing_kw_args_from(given_kw_args); end

  def non_kw_args_arity_description(); end

  def optional_kw_args(); end

  def required_kw_args(); end

  def unlimited_args?(); end

  def valid_non_kw_args?(positional_arg_count, optional_max_arg_count=T.unsafe(nil)); end
  INFINITY = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::MethodSignature
end

class RSpec::Support::MethodSignatureExpectation
  def empty?(); end

  def expect_arbitrary_keywords(); end

  def expect_arbitrary_keywords=(expect_arbitrary_keywords); end

  def expect_unlimited_arguments(); end

  def expect_unlimited_arguments=(expect_unlimited_arguments); end

  def keywords(); end

  def keywords=(values); end

  def max_count(); end

  def max_count=(number); end

  def min_count(); end

  def min_count=(number); end
end

class RSpec::Support::MethodSignatureExpectation
end

class RSpec::Support::MethodSignatureVerifier
  def error_message(); end

  def initialize(signature, args=T.unsafe(nil)); end

  def kw_args(); end

  def max_non_kw_args(); end

  def min_non_kw_args(); end

  def non_kw_args(); end

  def valid?(); end

  def with_expectation(expectation); end
end

class RSpec::Support::MethodSignatureVerifier
end

RSpec::Support::Mutex = Thread::Mutex

module RSpec::Support::OS
end

module RSpec::Support::OS
  def self.windows?(); end

  def self.windows_file_path?(); end
end

class RSpec::Support::ObjectFormatter
  def format(object); end

  def initialize(max_formatted_output_length=T.unsafe(nil)); end

  def max_formatted_output_length(); end

  def max_formatted_output_length=(max_formatted_output_length); end

  def prepare_array(array); end

  def prepare_element(element); end

  def prepare_for_inspection(object); end

  def prepare_hash(input_hash); end

  def recursive_structure?(object); end

  def sort_hash_keys(input_hash); end

  def with_entering_structure(structure); end
  ELLIPSIS = ::T.let(nil, ::T.untyped)
  INSPECTOR_CLASSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::BaseInspector
  def formatter(); end

  def formatter=(_); end

  def object(); end

  def object=(_); end

  def pretty_print(pp); end
end

class RSpec::Support::ObjectFormatter::BaseInspector
  def self.[](*_); end

  def self.can_inspect?(_object); end

  def self.members(); end
end

class RSpec::Support::ObjectFormatter::BigDecimalInspector
end

class RSpec::Support::ObjectFormatter::BigDecimalInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DelegatorInspector
end

class RSpec::Support::ObjectFormatter::DelegatorInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DescribableMatcherInspector
end

class RSpec::Support::ObjectFormatter::DescribableMatcherInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::InspectableItem
  def pretty_print(pp); end

  def text(); end

  def text=(_); end
end

class RSpec::Support::ObjectFormatter::InspectableItem
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Support::ObjectFormatter::InspectableObjectInspector
end

class RSpec::Support::ObjectFormatter::InspectableObjectInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::TimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::TimeInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  def klass(); end

  def native_object_id(); end
  OBJECT_ID_FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter
  def self.default_instance(); end

  def self.format(object); end

  def self.prepare_for_inspection(object); end
end

module RSpec::Support::RecursiveConstMethods
  def const_defined_on?(mod, const_name); end

  def constants_defined_on(mod); end

  def get_const_defined_on(mod, const_name); end

  def normalize_const_name(const_name); end

  def recursive_const_defined?(const_name); end

  def recursive_const_get(const_name); end
end

module RSpec::Support::RecursiveConstMethods
end

class RSpec::Support::ReentrantMutex
  def synchronize(); end
end

class RSpec::Support::ReentrantMutex
end

module RSpec::Support::Ruby
end

module RSpec::Support::Ruby
  def self.jruby?(); end

  def self.jruby_9000?(); end

  def self.jruby_version(); end

  def self.mri?(); end

  def self.non_mri?(); end

  def self.rbx?(); end
end

module RSpec::Support::RubyFeatures
end

module RSpec::Support::RubyFeatures
  def self.caller_locations_supported?(); end

  def self.fork_supported?(); end

  def self.kw_args_supported?(); end

  def self.module_prepends_supported?(); end

  def self.module_refinement_supported?(); end

  def self.optional_and_splat_args_supported?(); end

  def self.required_kw_args_supported?(); end

  def self.ripper_supported?(); end

  def self.supports_exception_cause?(); end

  def self.supports_rebinding_module_methods?(); end

  def self.supports_taint?(); end
end

RSpec::Support::StrictSignatureVerifier = RSpec::Support::MethodSignatureVerifier

module RSpec::Support::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::Version
end

module RSpec::Support::Warnings
  def deprecate(deprecated, options=T.unsafe(nil)); end

  def warn_deprecation(message, options=T.unsafe(nil)); end

  def warn_with(message, options=T.unsafe(nil)); end

  def warning(text, options=T.unsafe(nil)); end
end

module RSpec::Support::Warnings
end

module RSpec::Support
  def self.class_of(object); end

  def self.define_optimized_require_for_rspec(lib, &require_relative); end

  def self.deregister_matcher_definition(&block); end

  def self.failure_notifier(); end

  def self.failure_notifier=(callable); end

  def self.is_a_matcher?(object); end

  def self.matcher_definitions(); end

  def self.method_handle_for(object, method_name); end

  def self.notify_failure(failure, options=T.unsafe(nil)); end

  def self.register_matcher_definition(&block); end

  def self.require_rspec_core(f); end

  def self.require_rspec_expectations(f); end

  def self.require_rspec_matchers(f); end

  def self.require_rspec_mocks(f); end

  def self.require_rspec_support(f); end

  def self.rspec_description_for_object(object); end

  def self.thread_local_data(); end

  def self.warning_notifier(); end

  def self.warning_notifier=(warning_notifier); end

  def self.with_failure_notifier(callable); end
end

module RSpec::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Version
end

module RSpec
  extend ::RSpec::Support::Warnings
  extend ::RSpec::Core::Warnings
  def self.clear_examples(); end

  def self.configuration(); end

  def self.configuration=(configuration); end

  def self.configure(); end

  def self.const_missing(name); end

  def self.context(*args, &example_group_block); end

  def self.current_example(); end

  def self.current_example=(example); end

  def self.describe(*args, &example_group_block); end

  def self.example_group(*args, &example_group_block); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.reset(); end

  def self.world(); end

  def self.world=(world); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end
end

module Rake
  EARLY = ::T.let(nil, ::T.untyped)
  EMPTY_TASK_ARGS = ::T.let(nil, ::T.untyped)
  LATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rake::Application
  include ::Rake::TaskManager
  include ::Rake::TraceOutput
  def add_import(fn); end

  def add_loader(ext, loader); end

  def collect_command_line_tasks(args); end

  def default_task_name(); end

  def deprecate(old_usage, new_usage, call_site); end

  def display_cause_details(ex); end

  def display_error_message(ex); end

  def display_exception_backtrace(ex); end

  def display_exception_details(ex); end

  def display_exception_details_seen(); end

  def display_exception_message_details(ex); end

  def display_prerequisites(); end

  def display_tasks_and_comments(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def exit_because_of_exception(ex); end

  def find_rakefile_location(); end

  def handle_options(argv); end

  def has_cause?(ex); end

  def have_rakefile(); end

  def init(app_name=T.unsafe(nil), argv=T.unsafe(nil)); end

  def invoke_task(task_string); end

  def load_imports(); end

  def load_rakefile(); end

  def name(); end

  def options(); end

  def original_dir(); end

  def parse_task_string(string); end

  def print_rakefile_directory(location); end

  def rake_require(file_name, paths=T.unsafe(nil), loaded=T.unsafe(nil)); end

  def rakefile(); end

  def rakefile_location(backtrace=T.unsafe(nil)); end

  def raw_load_rakefile(); end

  def run(argv=T.unsafe(nil)); end

  def run_with_threads(); end

  def set_default_options(); end

  def standard_exception_handling(); end

  def standard_rake_options(); end

  def system_dir(); end

  def terminal_columns(); end

  def terminal_columns=(terminal_columns); end

  def terminal_width(); end

  def thread_pool(); end

  def top_level(); end

  def top_level_tasks(); end

  def trace(*strings); end

  def truncate(string, width); end

  def truncate_output?(); end

  def tty_output=(tty_output); end

  def tty_output?(); end

  def unix?(); end

  def windows?(); end
  DEFAULT_RAKEFILES = ::T.let(nil, ::T.untyped)
end

class Rake::Application
end

module Rake::Backtrace
  SUPPRESSED_PATHS = ::T.let(nil, ::T.untyped)
  SUPPRESSED_PATHS_RE = ::T.let(nil, ::T.untyped)
  SUPPRESS_PATTERN = ::T.let(nil, ::T.untyped)
  SYS_KEYS = ::T.let(nil, ::T.untyped)
  SYS_PATHS = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  def self.collapse(backtrace); end
end

module Rake::Cloneable
end

module Rake::Cloneable
end

class Rake::CommandLineOptionError
end

class Rake::CommandLineOptionError
end

class Rake::CpuCounter
  def count(); end

  def count_with_default(default=T.unsafe(nil)); end
end

class Rake::CpuCounter
  def self.count(); end
end

module Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Rake::DSL
end

class Rake::DefaultLoader
  def load(fn); end
end

class Rake::DefaultLoader
end

class Rake::EarlyTime
  include ::Comparable
  include ::Singleton
end

class Rake::EarlyTime
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Rake::FileCreationTask
end

class Rake::FileCreationTask
end

class Rake::FileList
  include ::Rake::Cloneable
  def &(*args, &block); end

  def *(other); end

  def +(*args, &block); end

  def -(*args, &block); end

  def <<(obj); end

  def ==(array); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def add(*filenames); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def clear_exclude(); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def difference(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def egrep(pattern, *options); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def exclude(*patterns, &block); end

  def excluded_from_list?(fn); end

  def existing(); end

  def existing!(); end

  def ext(newext=T.unsafe(nil)); end

  def fetch(*args, &block); end

  def fill(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def gsub(pat, rep); end

  def gsub!(pat, rep); end

  def import(array); end

  def include(*filenames); end

  def include?(*args, &block); end

  def index(*args, &block); end

  def initialize(*patterns); end

  def inject(*args, &block); end

  def insert(*args, &block); end

  def inspect(*args, &block); end

  def is_a?(klass); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def kind_of?(klass); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def partition(&block); end

  def pathmap(spec=T.unsafe(nil), &block); end

  def permutation(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def resolve(); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def sub(pat, rep); end

  def sub!(pat, rep); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def to_a(); end

  def to_ary(); end

  def to_h(*args, &block); end

  def to_set(*args, &block); end

  def transpose(*args, &block); end

  def union(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  GLOB_PATTERN = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

class Rake::FileList
  def self.[](*args); end

  def self.glob(pattern, *args); end
end

class Rake::FileTask
end

class Rake::FileTask
end

module Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def cd(*args, &block); end

  def chdir(*args, &block); end

  def chmod(*args, &block); end

  def chmod_R(*args, &block); end

  def chown(*args, &block); end

  def chown_R(*args, &block); end

  def copy(*args, &block); end

  def cp(*args, &block); end

  def cp_lr(*args, &block); end

  def cp_r(*args, &block); end

  def install(*args, &block); end

  def link(*args, &block); end

  def ln(*args, &block); end

  def ln_s(*args, &block); end

  def ln_sf(*args, &block); end

  def makedirs(*args, &block); end

  def mkdir(*args, &block); end

  def mkdir_p(*args, &block); end

  def mkpath(*args, &block); end

  def move(*args, &block); end

  def mv(*args, &block); end

  def nowrite(value=T.unsafe(nil)); end

  def rake_check_options(options, *optdecl); end

  def rake_merge_option(args, defaults); end

  def rake_output_message(message); end

  def remove(*args, &block); end

  def rm(*args, &block); end

  def rm_f(*args, &block); end

  def rm_r(*args, &block); end

  def rm_rf(*args, &block); end

  def rmdir(*args, &block); end

  def rmtree(*args, &block); end

  def safe_unlink(*args, &block); end

  def symlink(*args, &block); end

  def touch(*args, &block); end

  def verbose(value=T.unsafe(nil)); end

  def when_writing(msg=T.unsafe(nil)); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  def self.nowrite_flag(); end

  def self.nowrite_flag=(nowrite_flag); end

  def self.verbose_flag(); end

  def self.verbose_flag=(verbose_flag); end
end

class Rake::InvocationChain
  def append(invocation); end

  def member?(invocation); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::InvocationChain::EmptyInvocationChain
  def append(invocation); end

  def member?(obj); end
end

class Rake::InvocationChain::EmptyInvocationChain
end

class Rake::InvocationChain
  def self.append(invocation, chain); end
end

module Rake::InvocationExceptionMixin
  def chain(); end

  def chain=(value); end
end

module Rake::InvocationExceptionMixin
end

class Rake::LateTime
  include ::Comparable
  include ::Singleton
end

class Rake::LateTime
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Rake::LinkedList
  include ::Enumerable
  def ==(other); end

  def conj(item); end

  def each(&blk); end

  def empty?(); end

  def head(); end

  def initialize(head, tail=T.unsafe(nil)); end

  def tail(); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::LinkedList::EmptyLinkedList
  def initialize(); end
end

class Rake::LinkedList::EmptyLinkedList
end

class Rake::LinkedList
  def self.cons(head, tail); end

  def self.empty(); end

  def self.make(*args); end
end

class Rake::MultiTask
end

class Rake::MultiTask
end

class Rake::NameSpace
  def [](name); end

  def initialize(task_manager, scope_list); end

  def scope(); end

  def tasks(); end
end

class Rake::NameSpace
end

module Rake::PrivateReader
end

module Rake::PrivateReader::ClassMethods
  def private_reader(*names); end
end

module Rake::PrivateReader::ClassMethods
end

module Rake::PrivateReader
  def self.included(base); end
end

class Rake::Promise
  def initialize(args, &block); end

  def recorder(); end

  def recorder=(recorder); end

  def value(); end

  def work(); end
  NOT_SET = ::T.let(nil, ::T.untyped)
end

class Rake::Promise
end

class Rake::PseudoStatus
  def >>(n); end

  def exited?(); end

  def exitstatus(); end

  def initialize(code=T.unsafe(nil)); end

  def stopped?(); end

  def to_i(); end
end

class Rake::PseudoStatus
end

class Rake::RuleRecursionOverflowError
  def add_target(target); end

  def initialize(*args); end
end

class Rake::RuleRecursionOverflowError
end

class Rake::Scope
  def path(); end

  def path_with_task_name(task_name); end

  def trim(n); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::Scope::EmptyScope
  def path(); end

  def path_with_task_name(task_name); end
end

class Rake::Scope::EmptyScope
end

class Rake::Scope
end

class Rake::Task
  def actions(); end

  def add_description(description); end

  def all_prerequisite_tasks(); end

  def already_invoked(); end

  def application(); end

  def application=(application); end

  def arg_description(); end

  def arg_names(); end

  def clear(); end

  def clear_actions(); end

  def clear_args(); end

  def clear_comments(); end

  def clear_prerequisites(); end

  def collect_prerequisites(seen); end

  def comment(); end

  def comment=(comment); end

  def enhance(deps=T.unsafe(nil), &block); end

  def execute(args=T.unsafe(nil)); end

  def full_comment(); end

  def initialize(task_name, app); end

  def investigation(); end

  def invoke(*args); end

  def invoke_prerequisites(task_args, invocation_chain); end

  def invoke_prerequisites_concurrently(task_args, invocation_chain); end

  def invoke_with_call_chain(task_args, invocation_chain); end

  def locations(); end

  def name(); end

  def name_with_args(); end

  def needed?(); end

  def prereqs(); end

  def prerequisite_tasks(); end

  def prerequisites(); end

  def reenable(); end

  def scope(); end

  def set_arg_names(args); end

  def source(); end

  def sources(); end

  def sources=(sources); end

  def timestamp(); end
end

class Rake::Task
  def self.[](task_name); end

  def self.clear(); end

  def self.create_rule(*args, &block); end

  def self.define_task(*args, &block); end

  def self.scope_name(scope, task_name); end

  def self.task_defined?(task_name); end

  def self.tasks(); end
end

class Rake::TaskArgumentError
end

class Rake::TaskArgumentError
end

class Rake::TaskArguments
  include ::Enumerable
  def [](index); end

  def each(&block); end

  def extras(); end

  def fetch(*args, &block); end

  def has_key?(key); end

  def initialize(names, values, parent=T.unsafe(nil)); end

  def key?(key); end

  def lookup(name); end

  def method_missing(sym, *args); end

  def names(); end

  def new_scope(names); end

  def to_a(); end

  def to_hash(); end

  def values_at(*keys); end

  def with_defaults(defaults); end
end

class Rake::TaskArguments
end

module Rake::TaskManager
  def [](task_name, scopes=T.unsafe(nil)); end

  def clear(); end

  def create_rule(*args, &block); end

  def current_scope(); end

  def define_task(task_class, *args, &block); end

  def enhance_with_matching_rule(task_name, level=T.unsafe(nil)); end

  def generate_did_you_mean_suggestions(task_name); end

  def generate_message_for_undefined_task(task_name); end

  def in_namespace(name); end

  def initialize(); end

  def intern(task_class, task_name); end

  def last_description(); end

  def last_description=(last_description); end

  def lookup(task_name, initial_scope=T.unsafe(nil)); end

  def resolve_args(args); end

  def synthesize_file_task(task_name); end

  def tasks(); end

  def tasks_in_scope(scope); end
end

module Rake::TaskManager
  def self.record_task_metadata(); end

  def self.record_task_metadata=(record_task_metadata); end
end

class Rake::ThreadHistoryDisplay
  include ::Rake::PrivateReader
  def initialize(stats); end

  def show(); end
end

class Rake::ThreadHistoryDisplay
  extend ::Rake::PrivateReader::ClassMethods
end

class Rake::ThreadPool
  def future(*args, &block); end

  def gather_history(); end

  def history(); end

  def initialize(thread_count); end

  def join(); end

  def statistics(); end
end

class Rake::ThreadPool
end

module Rake::TraceOutput
  def trace_on(out, *strings); end
end

module Rake::TraceOutput
end

module Rake::Version
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  NUMBERS = ::T.let(nil, ::T.untyped)
  OTHER = ::T.let(nil, ::T.untyped)
end

module Rake::Version
end

module Rake::Win32
end

class Rake::Win32::Win32HomeError
end

class Rake::Win32::Win32HomeError
end

module Rake::Win32
  def self.normalize(path); end

  def self.win32_system_dir(); end

  def self.windows?(); end
end

module Rake
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  def self.add_rakelib(*files); end

  def self.application(); end

  def self.application=(app); end

  def self.each_dir_parent(dir); end

  def self.from_pathname(path); end

  def self.load_rakefile(path); end

  def self.original_dir(); end

  def self.suggested_thread_count(); end

  def self.with_application(block_application=T.unsafe(nil)); end
end

RakeFileUtils = Rake::FileUtilsExt

module Random::Formatter
  def alphanumeric(n=T.unsafe(nil)); end

  ALPHANUMERIC = ::T.let(nil, ::T.untyped)
end

class Random
  def self.bytes(_); end

  def self.urandom(_); end
end

class Range
  def %(_); end

  def entries(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

class Regexp
  def match?(*_); end
end

module RubyVM::AbstractSyntaxTree
end

class RubyVM::AbstractSyntaxTree::Node
  def children(); end

  def first_column(); end

  def first_lineno(); end

  def last_column(); end

  def last_lineno(); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def type(); end
end

class RubyVM::AbstractSyntaxTree::Node
end

module RubyVM::AbstractSyntaxTree
  def self.of(_); end

  def self.parse(_); end

  def self.parse_file(_); end
end

class RubyVM::InstructionSequence
  def absolute_path(); end

  def base_label(); end

  def disasm(); end

  def disassemble(); end

  def each_child(); end

  def eval(); end

  def first_lineno(); end

  def label(); end

  def path(); end

  def to_a(); end

  def to_binary(*_); end

  def trace_points(); end
end

class RubyVM::InstructionSequence
  def self.compile(*_); end

  def self.compile_file(*_); end

  def self.compile_option(); end

  def self.compile_option=(compile_option); end

  def self.disasm(_); end

  def self.disassemble(_); end

  def self.load_from_binary(_); end

  def self.load_from_binary_extra_data(_); end

  def self.of(_); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

class RubyVM
  def self.resolve_feature_path(_); end

  def self.stat(*_); end
end

ScanError = StringScanner::Error

module SecureRandom
  def self.bytes(n); end
end

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

module Shellwords
end

module Shellwords
  def self.escape(str); end

  def self.join(array); end

  def self.shellescape(str); end

  def self.shelljoin(array); end

  def self.shellsplit(line); end

  def self.shellwords(line); end

  def self.split(line); end
end

class SignalException
  def signm(); end

  def signo(); end
end

module SingleForwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_single_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_single_delegators(accessor, *methods); end

  def delegate(hash); end

  def single_delegate(hash); end
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::ConstantLookupCache
  def all_module_aliases(); end

  def all_module_names(); end

  def all_named_modules(); end

  def class_by_name(name); end

  def name_by_class(klass); end
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def aliases(); end

  def aliases=(_); end

  def const(); end

  def const=(_); end

  def const_name(); end

  def const_name=(_); end

  def found_name(); end

  def found_name=(_); end

  def owner(); end

  def owner=(_); end

  def primary_name(); end

  def primary_name=(_); end
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::ConstantLookupCache
end

class Sorbet::Private::CreateConfig
  include ::Sorbet::Private::StepInterface
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::CreateConfig
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::FetchRBIs
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
  SORBET_RBI_LIST = ::T.let(nil, ::T.untyped)
  SORBET_RBI_SORBET_TYPED = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REPO = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REVISION = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FetchRBIs
  def self.fetch_sorbet_typed(); end

  def self.main(); end

  def self.matching_version_directories(root, version); end

  def self.output_file(); end

  def self.paths_for_gem_version(gemspec); end

  def self.paths_for_ruby_version(ruby_version); end

  def self.vendor_rbis_within_paths(vendor_paths); end
end

class Sorbet::Private::FindGemRBIs
  include ::Sorbet::Private::StepInterface
  GEM_DIR = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FindGemRBIs
  def self.main(); end

  def self.output_file(); end

  def self.paths_within_gem_sources(gemspec); end
end

module Sorbet::Private::GemGeneratorTracepoint
  include ::Sorbet::Private::StepInterface
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def defs(); end

  def defs=(_); end

  def id(); end

  def id=(_); end

  def klass(); end

  def klass=(_); end
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
  def initialize(files:, delegate_classes:); end

  def serialize(output_dir); end
  BAD_METHODS = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
  def self.add_to_context(item); end

  def self.disable_tracepoints(); end

  def self.finish(); end

  def self.install_tracepoints(); end

  def self.on_method_added(mod, method, singleton); end

  def self.on_module_created(mod); end

  def self.on_module_extended(extended, extender); end

  def self.on_module_included(included, includer); end

  def self.pre_cache_module_methods(); end

  def self.register_delegate_class(klass, delegate); end

  def self.start(); end

  def self.trace(); end

  def self.trace_results(); end
end

module Sorbet::Private::GemGeneratorTracepoint
  def self.main(output_dir=T.unsafe(nil)); end

  def self.output_file(); end
end

class Sorbet::Private::GemLoader
  GEM_LOADER = ::T.let(nil, ::T.untyped)
  NO_GEM = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemLoader
  def self.my_require(gem); end

  def self.require_all_gems(); end

  def self.require_gem(gem); end
end

class Sorbet::Private::HiddenMethodFinder
  include ::Sorbet::Private::StepInterface
  def all_modules_and_aliases(); end

  def capture_stderr(); end

  def constant_cache(); end

  def gen_source_rbi(classes, aliases); end

  def looks_like_stub_name(name); end

  def main(); end

  def mk_dir(); end

  def read_constants(); end

  def real_name(mod); end

  def require_everything(); end

  def rm_dir(); end

  def serialize_alias(source_entry, rbi_entry, my_klass, source_symbols, rbi_symbols); end

  def serialize_class(source_entry, rbi_entry, klass, source_symbols, rbi_symbols, source_by_name); end

  def serialize_constants(source, rbi, klass, is_singleton, source_symbols, rbi_symbols); end

  def symbols_id_to_name(entry, prefix); end

  def write_constants(); end

  def write_diff(source, rbi); end
  BLACKLIST = ::T.let(nil, ::T.untyped)
  DIFF_RBI = ::T.let(nil, ::T.untyped)
  ERRORS_RBI = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  HIDDEN_RBI = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  TMP_PATH = ::T.let(nil, ::T.untyped)
  TMP_RBI = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::HiddenMethodFinder
  def self.main(); end

  def self.output_file(); end
end

module Sorbet::Private::Main
end

module Sorbet::Private::Main
  def self.cyan(msg); end

  def self.emojify(emoji, msg); end

  def self.init(); end

  def self.main(argv); end

  def self.make_step(step); end

  def self.usage(); end

  def self.yellow(msg); end
end

module Sorbet::Private::RealStdlib
end

module Sorbet::Private::RealStdlib
  def self.real_ancestors(mod); end

  def self.real_autoload?(o, klass); end

  def self.real_const_get(obj, const, arg); end

  def self.real_constants(mod); end

  def self.real_eqeq(obj, other); end

  def self.real_hash(o); end

  def self.real_instance_methods(mod, arg); end

  def self.real_is_a?(o, klass); end

  def self.real_method(obj, sym); end

  def self.real_name(o); end

  def self.real_object_id(o); end

  def self.real_private_instance_methods(mod, arg); end

  def self.real_singleton_class(obj); end

  def self.real_singleton_methods(mod, arg); end

  def self.real_spaceship(obj, arg); end

  def self.real_superclass(o); end
end

class Sorbet::Private::RequireEverything
end

class Sorbet::Private::RequireEverything
  def self.excluded_rails_files(); end

  def self.load_bundler(); end

  def self.load_rails(); end

  def self.my_require(abs_path, numerator, denominator); end

  def self.patch_kernel(); end

  def self.rails?(); end

  def self.rails_load_paths(); end

  def self.rb_file_paths(); end

  def self.require_all_files(); end

  def self.require_everything(); end
end

class Sorbet::Private::Serialize
  def alias(base, other_name); end

  def ancestor_has_method(method, klass); end

  def blacklisted_method(method); end

  def class_or_module(class_name); end

  def comparable?(value); end

  def constant(const, value); end

  def from_method(method); end

  def initialize(constant_cache); end

  def serialize_method(method, static=T.unsafe(nil), with_sig: T.unsafe(nil)); end

  def serialize_sig(parameters); end

  def to_sig(kind, name); end

  def valid_class_name(name); end

  def valid_method_name(name); end
  BLACKLIST_CONSTANTS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::Serialize
  def self.header(typed=T.unsafe(nil), subcommand=T.unsafe(nil)); end
end

module Sorbet::Private::Status
end

module Sorbet::Private::Status
  def self.done(); end

  def self.say(message, print_without_tty: T.unsafe(nil)); end
end

module Sorbet::Private::StepInterface
end

module Sorbet::Private::StepInterface
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::SuggestTyped
  include ::Sorbet::Private::StepInterface
end

class Sorbet::Private::SuggestTyped
  def self.main(); end

  def self.output_file(); end

  def self.suggest_typed(); end
end

class Sorbet::Private::TodoRBI
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::TodoRBI
  def self.main(); end

  def self.output_file(); end
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class StopIteration
  def result(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def []=(*_); end

  def casecmp?(_); end

  def each_grapheme_cluster(); end

  def encode!(*_); end

  def ext(newext=T.unsafe(nil)); end

  def grapheme_clusters(); end

  def parse_csv(**options); end

  def pathmap(spec=T.unsafe(nil), &block); end

  def pathmap_explode(); end

  def pathmap_partial(n); end

  def pathmap_replace(patterns, &block); end

  def reverse!(); end

  def shellescape(); end

  def shellsplit(); end

  def succ!(); end

  def undump(); end

  def unicode_normalize(*_); end

  def unicode_normalize!(*_); end

  def unicode_normalized?(*_); end

  def unpack1(_); end
end

class String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
end

class StringIO
  def length(); end

  def truncate(_); end
end

class StringScanner
  def <<(_); end

  def [](_); end

  def beginning_of_line?(); end

  def bol?(); end

  def captures(); end

  def charpos(); end

  def check(_); end

  def check_until(_); end

  def clear(); end

  def concat(_); end

  def empty?(); end

  def exist?(_); end

  def get_byte(); end

  def getbyte(); end

  def initialize(*_); end

  def match?(_); end

  def matched(); end

  def matched?(); end

  def matched_size(); end

  def peek(_); end

  def peep(_); end

  def pointer(); end

  def pointer=(pointer); end

  def pos(); end

  def pos=(pos); end

  def post_match(); end

  def pre_match(); end

  def reset(); end

  def rest(); end

  def rest?(); end

  def rest_size(); end

  def restsize(); end

  def scan_full(_, _1, _2); end

  def scan_until(_); end

  def search_full(_, _1, _2); end

  def size(); end

  def skip(_); end

  def skip_until(_); end

  def string(); end

  def string=(string); end

  def terminate(); end

  def unscan(); end

  def values_at(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def self.must_C_version(); end
end

class Struct
  def [](_); end

  def []=(_, _1); end

  def dig(*_); end

  def each_pair(); end

  def filter(*_); end

  def length(); end

  def members(); end

  def select(*_); end

  def size(); end

  def to_a(); end

  def to_h(); end

  def values(); end

  def values_at(*_); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class SystemCallError
  def errno(); end
end

class SystemExit
  def status(); end

  def success?(); end
end

class TracePoint
  def __enable(_, _1); end

  def eval_script(); end

  def event(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module URI
  include ::URI::RFC2396_REGEXP
end

module URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

class URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end

end

class UnboundMethod
  def clone(); end

  def original_name(); end
end

class UncaughtThrowError
  def tag(); end

  def value(); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

Visitor = Psych::Visitors::Visitor

module Warning
  def warn(_); end
end

module Warning
  extend ::Warning
end

YAML = Psych

YAMLTree = Psych::Visitors::YAMLTree

module Zlib
  ASCII = ::T.let(nil, ::T.untyped)
  BEST_COMPRESSION = ::T.let(nil, ::T.untyped)
  BEST_SPEED = ::T.let(nil, ::T.untyped)
  BINARY = ::T.let(nil, ::T.untyped)
  DEFAULT_COMPRESSION = ::T.let(nil, ::T.untyped)
  DEFAULT_STRATEGY = ::T.let(nil, ::T.untyped)
  DEF_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  FILTERED = ::T.let(nil, ::T.untyped)
  FINISH = ::T.let(nil, ::T.untyped)
  FIXED = ::T.let(nil, ::T.untyped)
  FULL_FLUSH = ::T.let(nil, ::T.untyped)
  HUFFMAN_ONLY = ::T.let(nil, ::T.untyped)
  MAX_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  MAX_WBITS = ::T.let(nil, ::T.untyped)
  NO_COMPRESSION = ::T.let(nil, ::T.untyped)
  NO_FLUSH = ::T.let(nil, ::T.untyped)
  OS_AMIGA = ::T.let(nil, ::T.untyped)
  OS_ATARI = ::T.let(nil, ::T.untyped)
  OS_CODE = ::T.let(nil, ::T.untyped)
  OS_CPM = ::T.let(nil, ::T.untyped)
  OS_MACOS = ::T.let(nil, ::T.untyped)
  OS_MSDOS = ::T.let(nil, ::T.untyped)
  OS_OS2 = ::T.let(nil, ::T.untyped)
  OS_QDOS = ::T.let(nil, ::T.untyped)
  OS_RISCOS = ::T.let(nil, ::T.untyped)
  OS_TOPS20 = ::T.let(nil, ::T.untyped)
  OS_UNIX = ::T.let(nil, ::T.untyped)
  OS_UNKNOWN = ::T.let(nil, ::T.untyped)
  OS_VMCMS = ::T.let(nil, ::T.untyped)
  OS_VMS = ::T.let(nil, ::T.untyped)
  OS_WIN32 = ::T.let(nil, ::T.untyped)
  OS_ZSYSTEM = ::T.let(nil, ::T.untyped)
  RLE = ::T.let(nil, ::T.untyped)
  SYNC_FLUSH = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  ZLIB_VERSION = ::T.let(nil, ::T.untyped)
end

class Zlib::BufError
end

class Zlib::BufError
end

class Zlib::DataError
end

class Zlib::DataError
end

class Zlib::Deflate
  def <<(_); end

  def deflate(*_); end

  def flush(*_); end

  def initialize(*_); end

  def params(_, _1); end

  def set_dictionary(_); end
end

class Zlib::Deflate
  def self.deflate(*_); end
end

class Zlib::Error
end

class Zlib::Error
end

class Zlib::GzipFile
  def close(); end

  def closed?(); end

  def comment(); end

  def crc(); end

  def finish(); end

  def level(); end

  def mtime(); end

  def orig_name(); end

  def os_code(); end

  def sync(); end

  def sync=(sync); end

  def to_io(); end
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::Error
  def input(); end
end

class Zlib::GzipFile::Error
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile
  def self.wrap(*_); end
end

class Zlib::GzipReader
  include ::Enumerable
  def bytes(); end

  def each(*_, &blk); end

  def each_byte(); end

  def each_char(); end

  def each_line(*_); end

  def eof(); end

  def eof?(); end

  def external_encoding(); end

  def getbyte(); end

  def getc(); end

  def initialize(*_); end

  def lineno(); end

  def lineno=(lineno); end

  def lines(*_); end

  def pos(); end

  def read(*_); end

  def readbyte(); end

  def readchar(); end

  def readpartial(*_); end

  def rewind(); end

  def tell(); end

  def ungetbyte(_); end

  def ungetc(_); end

  def unused(); end
end

class Zlib::GzipReader
end

class Zlib::GzipWriter
  def <<(_); end

  def comment=(comment); end

  def flush(*_); end

  def initialize(*_); end

  def mtime=(mtime); end

  def orig_name=(orig_name); end

  def pos(); end

  def tell(); end

  def write(*_); end
end

class Zlib::GzipWriter
end

class Zlib::Inflate
  def <<(_); end

  def add_dictionary(_); end

  def inflate(_); end

  def initialize(*_); end

  def set_dictionary(_); end

  def sync(_); end

  def sync_point?(); end
end

class Zlib::Inflate
  def self.inflate(_); end
end

class Zlib::MemError
end

class Zlib::MemError
end

class Zlib::NeedDict
end

class Zlib::NeedDict
end

class Zlib::StreamEnd
end

class Zlib::StreamEnd
end

class Zlib::StreamError
end

class Zlib::StreamError
end

class Zlib::VersionError
end

class Zlib::VersionError
end

class Zlib::ZStream
  def adler(); end

  def avail_in(); end

  def avail_out(); end

  def avail_out=(avail_out); end

  def close(); end

  def closed?(); end

  def data_type(); end

  def end(); end

  def ended?(); end

  def finish(); end

  def finished?(); end

  def flush_next_in(); end

  def flush_next_out(); end

  def reset(); end

  def stream_end?(); end

  def total_in(); end

  def total_out(); end
end

class Zlib::ZStream
end

module Zlib
  def self.adler32(*_); end

  def self.adler32_combine(_, _1, _2); end

  def self.crc32(*_); end

  def self.crc32_combine(_, _1, _2); end

  def self.crc_table(); end

  def self.deflate(*_); end

  def self.gunzip(_); end

  def self.gzip(*_); end

  def self.inflate(_); end

  def self.zlib_version(); end
end
